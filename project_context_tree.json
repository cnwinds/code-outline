{
  "projectName": "CodeCartographer",
  "projectGoal": "TODO: 请在此描述项目目标和主要功能",
  "techStack": [
    "Go",
    "JavaScript",
    "Python"
  ],
  "lastUpdated": "2025-10-07T17:11:01.4095429+08:00",
  "architecture": {
    "overview": "TODO: 请在此描述项目的整体架构",
    "moduleSummary": {
      "cmd\\contextgen": "包含 1 个文件: main.go",
      "internal\\cmd": "包含 1 个文件: root.go",
      "internal\\config": "包含 2 个文件，主要用于 TODO: 请描述此模块的用途",
      "internal\\models": "包含 1 个文件: types.go",
      "internal\\parser": "包含 3 个文件，主要用于 TODO: 请描述此模块的用途",
      "internal\\parser\\testdata": "包含 3 个文件，主要用于 TODO: 请描述此模块的用途",
      "internal\\scanner": "包含 2 个文件，主要用于 TODO: 请描述此模块的用途",
      "internal\\updater": "包含 1 个文件: incremental.go"
    }
  },
  "files": {
    "cmd\\contextgen\\main.go": {
      "purpose": "TODO: Describe the purpose of this file.",
      "symbols": [
        {
          "prototype": "func main() {\n\tif err := cmd.Execute(Version); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"错误: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n}",
          "purpose": "",
          "range": [
            14,
            19
          ]
        },
        {
          "prototype": "var Version = \"v0.1.0\"",
          "purpose": "",
          "range": [
            11,
            11
          ]
        }
      ],
      "lastModified": "2025-10-07T16:36:19+08:00",
      "fileSize": 327
    },
    "internal\\cmd\\root.go": {
      "purpose": "TODO: Describe the purpose of this file.",
      "symbols": [
        {
          "prototype": "func init() {\n\t// 添加子命令\n\trootCmd.AddCommand(generateCmd)\n\trootCmd.AddCommand(updateCmd)\n\n\t// 添加generate命令行参数\n\tgenerateCmd.Flags().StringVarP(\u0026projectPath, \"path\", \"p\", \".\", \"项目路径\")\n\tgenerateCmd.Flags().StringVarP(\u0026outputPath, \"output\", \"o\", \"project_context.json\", \"输出文件路径\")\n\tgenerateCmd.Flags().StringVarP(\u0026configPath, \"config\", \"c\", \"\", \"语言配置文件路径\")\n\tgenerateCmd.Flags().StringVarP(\u0026excludeDirs, \"exclude\", \"e\", \"\", \"要排除的目录或文件模式，用逗号分隔\")\n\tgenerateCmd.Flags().BoolVarP(\u0026useTreeSitter, \"treesitter\", \"t\", true, \"使用 Tree-sitter 解析器（默认: true）\")\n\n\t// 添加update命令行参数\n\tupdateCmd.Flags().StringVarP(\u0026projectPath, \"path\", \"p\", \".\", \"项目路径\")\n\tupdateCmd.Flags().StringVarP(\u0026outputPath, \"output\", \"o\", \"project_context.json\", \"输出文件路径\")\n\tupdateCmd.Flags().StringVarP(\u0026configPath, \"config\", \"c\", \"\", \"语言配置文件路径\")\n\tupdateCmd.Flags().StringVarP(\u0026excludeDirs, \"exclude\", \"e\", \"\", \"要排除的目录或文件模式，用逗号分隔\")\n\tupdateCmd.Flags().BoolVarP(\u0026useTreeSitter, \"treesitter\", \"t\", true, \"使用 Tree-sitter 解析器（默认: true）\")\n}",
          "purpose": "",
          "range": [
            55,
            73
          ]
        },
        {
          "prototype": "func Execute(version string) error {\n\t// 添加版本命令\n\tversionCmd := \u0026cobra.Command{\n\t\tUse:   \"version\",\n\t\tShort: \"显示版本信息\",\n\t\tRun: func(cmd *cobra.Command, args []string) {\n\t\t\tfmt.Printf(\"CodeCartographer %s\\n\", version)\n\t\t\tfmt.Printf(\"Go版本: %s\\n\", runtime.Version())\n\t\t\tfmt.Printf(\"操作系统: %s/%s\\n\", runtime.GOOS, runtime.GOARCH)\n\t\t},\n\t}\n\trootCmd.AddCommand(versionCmd)\n\n\treturn rootCmd.Execute()\n}",
          "purpose": "",
          "range": [
            76,
            90
          ]
        },
        {
          "prototype": "func runGenerate(cmd *cobra.Command, args []string) error {\n\tfmt.Println(\"🚀 开始生成项目上下文...\")\n\n\t// 1. 加载语言配置\n\tfmt.Println(\"📋 加载语言配置...\")\n\tlanguagesConfig, err := config.LoadLanguagesConfig(configPath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"加载语言配置失败: %w\", err)\n\t}\n\tfmt.Printf(\"✅ 已加载 %d 种语言的配置\\n\", len(languagesConfig))\n\n\t// 2. 创建解析器\n\tfmt.Println(\"🔧 初始化解析器...\")\n\tvar codeParser scanner.FileParser\n\tif useTreeSitter {\n\t\tfmt.Println(\"🌳 使用 Tree-sitter 解析器\")\n\t\ttreeSitterParser, err := parser.NewTreeSitterParser(languagesConfig)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"⚠️  Tree-sitter 初始化失败，回退到简单解析器: %v\\n\", err)\n\t\t\tcodeParser = parser.NewSimpleParser(languagesConfig)\n\t\t} else {\n\t\t\tcodeParser = treeSitterParser\n\t\t}\n\t} else {\n\t\tfmt.Println(\"📝 使用简单正则表达式解析器\")\n\t\tcodeParser = parser.NewSimpleParser(languagesConfig)\n\t}\n\n\t// 3. 解析排除模式\n\tvar excludePatterns []string\n\tif excludeDirs != \"\" {\n\t\texcludePatterns = strings.Split(excludeDirs, \",\")\n\t\tfor i, pattern := range excludePatterns {\n\t\t\texcludePatterns[i] = strings.TrimSpace(pattern)\n\t\t}\n\t}\n\n\t// 4. 创建扫描器并扫描项目\n\tfmt.Printf(\"🔍 扫描项目: %s\\n\", projectPath)\n\tfileScanner := scanner.NewScanner(codeParser, excludePatterns)\n\tfiles, techStack, err := fileScanner.ScanProject(projectPath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"扫描项目失败: %w\", err)\n\t}\n\tfmt.Printf(\"✅ 扫描完成，找到 %d 个文件\\n\", len(files))\n\n\t// 5. 构建项目上下文\n\tfmt.Println(\"📦 构建项目上下文...\")\n\tprojectName := filepath.Base(projectPath)\n\tif projectName == \".\" {\n\t\tif cwd, err := os.Getwd(); err == nil {\n\t\t\tprojectName = filepath.Base(cwd)\n\t\t} else {\n\t\t\tprojectName = \"Unknown Project\"\n\t\t}\n\t}\n\n\tcontext := models.ProjectContext{\n\t\tProjectName: projectName,\n\t\tProjectGoal: \"TODO: 请在此描述项目目标和主要功能\",\n\t\tTechStack:   techStack,\n\t\tLastUpdated: time.Now(),\n\t\tArchitecture: models.Architecture{\n\t\t\tOverview:      \"TODO: 请在此描述项目的整体架构\",\n\t\t\tModuleSummary: generateModuleSummary(files),\n\t\t},\n\t\tFiles: files,\n\t}\n\n\t// 6. 生成JSON文件\n\tfmt.Printf(\"💾 生成输出文件: %s\\n\", outputPath)\n\terr = saveProjectContext(\u0026context, outputPath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"保存项目上下文失败: %w\", err)\n\t}\n\n\t// 7. 显示统计信息\n\tprintStatistics(\u0026context)\n\n\tfmt.Println(\"🎉 项目上下文生成完成!\")\n\treturn nil\n}",
          "purpose": "",
          "range": [
            93,
            174
          ]
        },
        {
          "prototype": "func generateModuleSummary(files map[string]models.FileInfo) map[string]string {\n\tmoduleSummary := make(map[string]string)\n\n\t// 按目录分组文件\n\tdirGroups := make(map[string][]string)\n\tfor filePath := range files {\n\t\tdir := filepath.Dir(filePath)\n\t\tif dir == \".\" {\n\t\t\tdir = \"root\"\n\t\t}\n\t\tdirGroups[dir] = append(dirGroups[dir], filePath)\n\t}\n\n\t// 为每个目录生成摘要\n\tfor dir, fileList := range dirGroups {\n\t\tif len(fileList) == 1 {\n\t\t\tmoduleSummary[dir] = fmt.Sprintf(\"包含 1 个文件: %s\", filepath.Base(fileList[0]))\n\t\t} else {\n\t\t\tmoduleSummary[dir] = fmt.Sprintf(\"包含 %d 个文件，主要用于 TODO: 请描述此模块的用途\", len(fileList))\n\t\t}\n\t}\n\n\treturn moduleSummary\n}",
          "purpose": "",
          "range": [
            177,
            200
          ]
        },
        {
          "prototype": "func saveProjectContext(context *models.ProjectContext, outputPath string) error {\n\t// 创建输出目录（如果不存在）\n\tif err := os.MkdirAll(filepath.Dir(outputPath), 0755); err != nil {\n\t\treturn err\n\t}\n\n\t// 序列化为JSON\n\tdata, err := json.MarshalIndent(context, \"\", \"  \")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// 写入文件\n\treturn os.WriteFile(outputPath, data, 0644)\n}",
          "purpose": "",
          "range": [
            203,
            217
          ]
        },
        {
          "prototype": "func runUpdate(cmd *cobra.Command, args []string) error {\n\tfmt.Println(\"🔄 开始增量更新项目上下文...\")\n\n\t// 1. 加载语言配置\n\tlanguagesConfig, err := config.LoadLanguagesConfig(configPath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"加载语言配置失败: %w\", err)\n\t}\n\n\t// 2. 创建解析器\n\tvar fileParser scanner.FileParser\n\tif useTreeSitter {\n\t\tfmt.Println(\"🌳 使用 Tree-sitter 解析器\")\n\t\ttreeSitterParser, err := parser.NewTreeSitterParser(languagesConfig)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"⚠️  Tree-sitter 初始化失败，回退到简单解析器: %v\\n\", err)\n\t\t\tfileParser = parser.NewSimpleParser(languagesConfig)\n\t\t} else {\n\t\t\tfileParser = treeSitterParser\n\t\t}\n\t} else {\n\t\tfmt.Println(\"📝 使用简单正则表达式解析器\")\n\t\tfileParser = parser.NewSimpleParser(languagesConfig)\n\t}\n\n\t// 3. 创建增量更新器\n\tincrementalUpdater := updater.NewIncrementalUpdater(fileParser)\n\n\t// 4. 解析排除模式\n\tvar excludePatterns []string\n\tif excludeDirs != \"\" {\n\t\texcludePatterns = strings.Split(excludeDirs, \",\")\n\t\tfor i, pattern := range excludePatterns {\n\t\t\texcludePatterns[i] = strings.TrimSpace(pattern)\n\t\t}\n\t}\n\n\t// 5. 执行增量更新\n\tupdatedContext, changes, err := incrementalUpdater.UpdateProject(outputPath, projectPath, excludePatterns)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"增量更新失败: %w\", err)\n\t}\n\n\t// 6. 如果有变更，保存更新后的上下文\n\tif len(changes) \u003e 0 {\n\t\tfmt.Printf(\"\\n📝 应用了 %d 个文件变更\\n\", len(changes))\n\n\t\tif err := saveProjectContext(updatedContext, outputPath); err != nil {\n\t\t\treturn fmt.Errorf(\"保存更新后的上下文失败: %w\", err)\n\t\t}\n\n\t\tfmt.Printf(\"💾 更新文件: %s\\n\", outputPath)\n\t}\n\n\t// 7. 打印统计信息\n\tprintUpdateStatistics(updatedContext, changes)\n\n\treturn nil\n}",
          "purpose": "",
          "range": [
            220,
            278
          ]
        },
        {
          "prototype": "func printStatistics(context *models.ProjectContext) {\n\tfmt.Println(\"\\n📊 统计信息:\")\n\tfmt.Printf(\"  项目名称: %s\\n\", context.ProjectName)\n\tfmt.Printf(\"  技术栈: %s\\n\", strings.Join(context.TechStack, \", \"))\n\tfmt.Printf(\"  文件数量: %d\\n\", len(context.Files))\n\tfmt.Printf(\"  模块数量: %d\\n\", len(context.Architecture.ModuleSummary))\n\n\t// 统计符号数量\n\ttotalSymbols := 0\n\tfor _, fileInfo := range context.Files {\n\t\ttotalSymbols += len(fileInfo.Symbols)\n\t}\n\tfmt.Printf(\"  符号数量: %d\\n\", totalSymbols)\n\n\tfmt.Printf(\"  最后更新: %s\\n\", context.LastUpdated.Format(\"2006-01-02 15:04:05\"))\n}",
          "purpose": "",
          "range": [
            281,
            296
          ]
        },
        {
          "prototype": "func printUpdateStatistics(context *models.ProjectContext, changes []updater.FileChange) {\n\tfmt.Printf(\"\\n📊 更新统计:\\n\")\n\n\taddedCount := 0\n\tmodifiedCount := 0\n\tdeletedCount := 0\n\n\tfor _, change := range changes {\n\t\tswitch change.ChangeType {\n\t\tcase updater.FileAdded:\n\t\t\taddedCount++\n\t\tcase updater.FileModified:\n\t\t\tmodifiedCount++\n\t\tcase updater.FileDeleted:\n\t\t\tdeletedCount++\n\t\t}\n\t}\n\n\tif len(changes) \u003e 0 {\n\t\tfmt.Printf(\"  📁 文件变更: +%d ✏️%d 🗑️%d\\n\", addedCount, modifiedCount, deletedCount)\n\t}\n\n\tfmt.Printf(\"  📄 总文件数量: %d\\n\", len(context.Files))\n\n\t// 统计符号数量\n\tsymbolCount := 0\n\tfor _, fileInfo := range context.Files {\n\t\tsymbolCount += len(fileInfo.Symbols)\n\t}\n\tfmt.Printf(\"  🔍 总符号数量: %d\\n\", symbolCount)\n\tfmt.Printf(\"  ⏰ 最后更新: %s\\n\", context.LastUpdated.Format(\"2006-01-02 15:04:05\"))\n}",
          "purpose": "",
          "range": [
            299,
            330
          ]
        },
        {
          "prototype": "var (\n\tprojectPath   string\n\toutputPath    string\n\tconfigPath    string\n\texcludeDirs   string\n\tuseTreeSitter bool\n)",
          "purpose": "",
          "range": [
            20,
            26
          ]
        },
        {
          "prototype": "var rootCmd = \u0026cobra.Command{\n\tUse:   \"contextgen\",\n\tShort: \"CodeCartographer - 通用型项目上下文生成器\",\n\tLong: `CodeCartographer 是一个高性能、跨平台的命令行工具，\n用于通过静态分析为任何复杂的代码仓库生成统一、简洁且信息丰富的 project_context.json 文件。\n\n此文件将作为大语言模型（LLM）的\"全局上下文记忆\"，使其能够以前所未有的\n准确性和深度来理解项目架构，从而提升代码生成、需求变更、重构和调试等任务的表现。`,\n}",
          "purpose": "",
          "range": [
            29,
            37
          ]
        },
        {
          "prototype": "var generateCmd = \u0026cobra.Command{\n\tUse:   \"generate\",\n\tShort: \"生成项目上下文文件\",\n\tLong:  `扫描指定项目目录，解析代码文件，并生成 project_context.json 文件。`,\n\tRunE:  runGenerate,\n}",
          "purpose": "",
          "range": [
            40,
            45
          ]
        },
        {
          "prototype": "var updateCmd = \u0026cobra.Command{\n\tUse:   \"update\",\n\tShort: \"增量更新项目上下文文件\",\n\tLong:  `检测文件变更并增量更新现有的 project_context.json 文件，只重新解析已修改的文件。`,\n\tRunE:  runUpdate,\n}",
          "purpose": "",
          "range": [
            48,
            53
          ]
        },
        {
          "prototype": "var codeParser scanner.FileParser",
          "purpose": "",
          "range": [
            106,
            106
          ]
        },
        {
          "prototype": "var excludePatterns []string",
          "purpose": "",
          "range": [
            122,
            122
          ]
        },
        {
          "prototype": "var fileParser scanner.FileParser",
          "purpose": "",
          "range": [
            230,
            230
          ]
        },
        {
          "prototype": "var excludePatterns []string",
          "purpose": "",
          "range": [
            249,
            249
          ]
        }
      ],
      "lastModified": "2025-10-07T16:36:19+08:00",
      "fileSize": 10418
    },
    "internal\\config\\config.go": {
      "purpose": "TODO: Describe the purpose of this file.",
      "symbols": [
        {
          "prototype": "func LoadLanguagesConfig(configPath string) (models.LanguagesConfig, error) {\n\t// 如果没有指定配置路径，使用默认路径\n\tif configPath == \"\" {\n\t\tconfigPath = \"languages.json\"\n\t}\n\n\t// 检查文件是否存在\n\tif _, err := os.Stat(configPath); os.IsNotExist(err) {\n\t\t// 如果配置文件不存在，创建默认配置\n\t\treturn createDefaultLanguagesConfig(configPath)\n\t}\n\n\t// 读取配置文件\n\tdata, err := os.ReadFile(configPath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"读取配置文件失败: %w\", err)\n\t}\n\n\tvar config models.LanguagesConfig\n\tif err := json.Unmarshal(data, \u0026config); err != nil {\n\t\treturn nil, fmt.Errorf(\"解析配置文件失败: %w\", err)\n\t}\n\n\treturn config, nil\n}",
          "purpose": "",
          "range": [
            21,
            45
          ]
        },
        {
          "prototype": "func createDefaultLanguagesConfig(configPath string) (models.LanguagesConfig, error) {\n\tdefaultConfig := models.LanguagesConfig{\n\t\t\"go\": {\n\t\t\tExtensions: []string{\".go\"},\n\t\t\tQueries: models.Queries{\n\t\t\t\tTopLevelSymbols: []string{\n\t\t\t\t\t\"(function_declaration) @symbol\",\n\t\t\t\t\t\"(method_declaration) @symbol\",\n\t\t\t\t\t\"(type_declaration) @symbol\",\n\t\t\t\t\t\"(const_declaration) @symbol\",\n\t\t\t\t\t\"(var_declaration) @symbol\",\n\t\t\t\t},\n\t\t\t\tContainerBody:    \"(block) @body | (struct_type) @body | (interface_type) @body\",\n\t\t\t\tContainerMethods: \"(method_declaration) @method\",\n\t\t\t},\n\t\t},\n\t\t\"javascript\": {\n\t\t\tExtensions: []string{\".js\", \".jsx\"},\n\t\t\tQueries: models.Queries{\n\t\t\t\tTopLevelSymbols: []string{\n\t\t\t\t\t\"(function_declaration) @symbol\",\n\t\t\t\t\t\"(arrow_function) @symbol\",\n\t\t\t\t\t\"(class_declaration) @symbol\",\n\t\t\t\t\t\"(const_declaration) @symbol\",\n\t\t\t\t\t\"(let_declaration) @symbol\",\n\t\t\t\t\t\"(var_declaration) @symbol\",\n\t\t\t\t},\n\t\t\t\tContainerBody:    \"(class_body) @body | (object) @body\",\n\t\t\t\tContainerMethods: \"(method_definition) @method\",\n\t\t\t},\n\t\t},\n\t\t\"python\": {\n\t\t\tExtensions: []string{\".py\"},\n\t\t\tQueries: models.Queries{\n\t\t\t\tTopLevelSymbols: []string{\n\t\t\t\t\t\"(function_definition) @symbol\",\n\t\t\t\t\t\"(class_definition) @symbol\",\n\t\t\t\t\t\"(assignment) @symbol\",\n\t\t\t\t},\n\t\t\t\tContainerBody:    \"(block) @body\",\n\t\t\t\tContainerMethods: \"(function_definition) @method\",\n\t\t\t},\n\t\t},\n\t}\n\n\t// 创建配置文件目录\n\tif err := os.MkdirAll(filepath.Dir(configPath), 0755); err != nil {\n\t\treturn nil, fmt.Errorf(\"创建配置目录失败: %w\", err)\n\t}\n\n\t// 写入默认配置文件\n\tdata, err := json.MarshalIndent(defaultConfig, \"\", \"  \")\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"序列化默认配置失败: %w\", err)\n\t}\n\n\tif err := os.WriteFile(configPath, data, 0644); err != nil {\n\t\treturn nil, fmt.Errorf(\"写入配置文件失败: %w\", err)\n\t}\n\n\tfmt.Printf(\"已创建默认配置文件: %s\\n\", configPath)\n\treturn defaultConfig, nil\n}",
          "purpose": "",
          "range": [
            48,
            110
          ]
        },
        {
          "prototype": "func GetLanguageByExtension(config models.LanguagesConfig, ext string) (string, models.LanguageConfig, bool) {\n\tfor langName, langConfig := range config {\n\t\tfor _, supportedExt := range langConfig.Extensions {\n\t\t\tif supportedExt == ext {\n\t\t\t\treturn langName, langConfig, true\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\", models.LanguageConfig{}, false\n}",
          "purpose": "",
          "range": [
            113,
            122
          ]
        },
        {
          "prototype": "type Config struct {\n\tLanguages   models.LanguagesConfig\n\tOutput      string\n\tExclude     []string\n\tProjectPath string\n}",
          "purpose": "",
          "range": [
            13,
            18
          ]
        },
        {
          "prototype": "var config models.LanguagesConfig",
          "purpose": "",
          "range": [
            39,
            39
          ]
        }
      ],
      "lastModified": "2025-10-07T16:36:19+08:00",
      "fileSize": 3434
    },
    "internal\\config\\config_test.go": {
      "purpose": "TODO: Describe the purpose of this file.",
      "symbols": [
        {
          "prototype": "func TestLoadLanguagesConfig(t *testing.T) {\r\n\t// 创建临时配置文件\r\n\ttmpDir := t.TempDir()\r\n\tconfigPath := filepath.Join(tmpDir, \"test_languages.json\")\r\n\r\n\t// 写入测试配置\r\n\r\n\tconfigData := `{\r\n\t\t\"go\": {\r\n\t\t\t\"extensions\": [\".go\"],\r\n\t\t\t\"queries\": {\r\n\t\t\t\t\"top_level_symbols\": [\"(function_declaration) @symbol\"]\r\n\t\t\t}\r\n\t\t}\r\n\t}`\r\n\r\n\terr := os.WriteFile(configPath, []byte(configData), 0644)\r\n\trequire.NoError(t, err)\r\n\r\n\t// 测试加载配置\r\n\tconfig, err := LoadLanguagesConfig(configPath)\r\n\trequire.NoError(t, err)\r\n\tassert.NotNil(t, config)\r\n\tassert.Contains(t, config, \"go\")\r\n}",
          "purpose": "",
          "range": [
            13,
            37
          ]
        },
        {
          "prototype": "func TestLoadLanguagesConfigFileNotExist(t *testing.T) {\r\n\t// 测试不存在的配置文件\r\n\ttmpDir := t.TempDir()\r\n\tconfigPath := filepath.Join(tmpDir, \"nonexistent.json\")\r\n\r\n\tconfig, err := LoadLanguagesConfig(configPath)\r\n\trequire.NoError(t, err)\r\n\tassert.NotNil(t, config)\r\n\r\n\t// 验证默认配置被创建\r\n\tassert.Contains(t, config, \"go\")\r\n\tassert.Contains(t, config, \"javascript\")\r\n\tassert.Contains(t, config, \"python\")\r\n}",
          "purpose": "",
          "range": [
            39,
            52
          ]
        },
        {
          "prototype": "func TestLoadLanguagesConfigInvalidJSON(t *testing.T) {\r\n\t// 创建无效的JSON文件\r\n\ttmpDir := t.TempDir()\r\n\tconfigPath := filepath.Join(tmpDir, \"invalid.json\")\r\n\r\n\tinvalidJSON := `{ invalid json }`\r\n\terr := os.WriteFile(configPath, []byte(invalidJSON), 0644)\r\n\trequire.NoError(t, err)\r\n\r\n\t// 测试加载无效配置\r\n\t_, err = LoadLanguagesConfig(configPath)\r\n\tassert.Error(t, err)\r\n\tassert.Contains(t, err.Error(), \"解析配置文件失败\")\r\n}",
          "purpose": "",
          "range": [
            54,
            67
          ]
        },
        {
          "prototype": "func TestGetLanguageByExtension(t *testing.T) {\r\n\tconfig := models.LanguagesConfig{\r\n\t\t\"go\": {\r\n\t\t\tExtensions: []string{\".go\"},\r\n\t\t},\r\n\t\t\"javascript\": {\r\n\t\t\tExtensions: []string{\".js\", \".jsx\"},\r\n\t\t},\r\n\t}\r\n\r\n\t// 测试存在的扩展名\r\n\tlangName, langConfig, found := GetLanguageByExtension(config, \".go\")\r\n\tassert.True(t, found)\r\n\tassert.Equal(t, \"go\", langName)\r\n\tassert.Equal(t, []string{\".go\"}, langConfig.Extensions)\r\n\r\n\t// 测试不存在的扩展名\r\n\t_, _, found = GetLanguageByExtension(config, \".py\")\r\n\tassert.False(t, found)\r\n\r\n\t// 测试JavaScript扩展名\r\n\tlangName, langConfig, found = GetLanguageByExtension(config, \".js\")\r\n\tassert.True(t, found)\r\n\tassert.Equal(t, \"javascript\", langName)\r\n\tassert.Equal(t, []string{\".js\", \".jsx\"}, langConfig.Extensions)\r\n}",
          "purpose": "",
          "range": [
            69,
            94
          ]
        },
        {
          "prototype": "func TestCreateDefaultLanguagesConfig(t *testing.T) {\r\n\ttmpDir := t.TempDir()\r\n\tconfigPath := filepath.Join(tmpDir, \"default_languages.json\")\r\n\r\n\tconfig, err := createDefaultLanguagesConfig(configPath)\r\n\trequire.NoError(t, err)\r\n\tassert.NotNil(t, config)\r\n\r\n\t// 验证默认配置包含预期语言\r\n\tassert.Contains(t, config, \"go\")\r\n\tassert.Contains(t, config, \"javascript\")\r\n\tassert.Contains(t, config, \"python\")\r\n\r\n\t// 验证配置文件被创建\r\n\t_, err = os.Stat(configPath)\r\n\tassert.NoError(t, err)\r\n\r\n\t// 验证配置文件内容\r\n\tcontent, err := os.ReadFile(configPath)\r\n\trequire.NoError(t, err)\r\n\tassert.Contains(t, string(content), \"go\")\r\n\tassert.Contains(t, string(content), \"javascript\")\r\n}",
          "purpose": "",
          "range": [
            96,
            118
          ]
        },
        {
          "prototype": "func TestCreateDefaultLanguagesConfigDirectoryCreation(t *testing.T) {\r\n\t// 测试在深层目录中创建配置文件\r\n\ttmpDir := t.TempDir()\r\n\tdeepDir := filepath.Join(tmpDir, \"deep\", \"nested\", \"directory\")\r\n\tconfigPath := filepath.Join(deepDir, \"languages.json\")\r\n\r\n\tconfig, err := createDefaultLanguagesConfig(configPath)\r\n\trequire.NoError(t, err)\r\n\tassert.NotNil(t, config)\r\n\r\n\t// 验证目录被创建\r\n\t_, err = os.Stat(deepDir)\r\n\tassert.NoError(t, err)\r\n\r\n\t// 验证配置文件被创建\r\n\t_, err = os.Stat(configPath)\r\n\tassert.NoError(t, err)\r\n}",
          "purpose": "",
          "range": [
            120,
            137
          ]
        },
        {
          "prototype": "func TestConfigStruct(t *testing.T) {\r\n\t// 测试Config结构体\r\n\tconfig := Config{\r\n\t\tLanguages: models.LanguagesConfig{\r\n\t\t\t\"go\": {\r\n\t\t\t\tExtensions: []string{\".go\"},\r\n\t\t\t},\r\n\t\t},\r\n\t\tOutput:      \"output.json\",\r\n\t\tExclude:     []string{\"node_modules\"},\r\n\t\tProjectPath: \"/path/to/project\",\r\n\t}\r\n\r\n\tassert.NotNil(t, config.Languages)\r\n\tassert.Equal(t, \"output.json\", config.Output)\r\n\tassert.Equal(t, []string{\"node_modules\"}, config.Exclude)\r\n\tassert.Equal(t, \"/path/to/project\", config.ProjectPath)\r\n}",
          "purpose": "",
          "range": [
            139,
            156
          ]
        }
      ],
      "lastModified": "2025-10-07T16:36:19+08:00",
      "fileSize": 4245
    },
    "internal\\models\\types.go": {
      "purpose": "Symbol 表示代码中的一个符号（如函数、结构体、常量等）",
      "symbols": [
        {
          "prototype": "type Symbol struct {\n\tPrototype string   `json:\"prototype\"`         // 符号的完整声明行\n\tPurpose   string   `json:\"purpose\"`           // 从注释中提取的说明\n\tRange     []int    `json:\"range\"`             // [start_line, end_line]\n\tBody      string   `json:\"body,omitempty\"`    // 用于类/结构体/接口等容器类型的内部内容\n\tMethods   []Symbol `json:\"methods,omitempty\"` // 用于类/结构体的方法\n}",
          "purpose": "",
          "range": [
            6,
            12
          ]
        },
        {
          "prototype": "type FileInfo struct {\n\tPurpose      string   `json:\"purpose\"`      // 文件的用途描述\n\tSymbols      []Symbol `json:\"symbols\"`      // 文件中的符号列表\n\tLastModified string   `json:\"lastModified\"` // 文件最后修改时间\n\tFileSize     int64    `json:\"fileSize\"`     // 文件大小\n}",
          "purpose": "",
          "range": [
            15,
            20
          ]
        },
        {
          "prototype": "type Architecture struct {\n\tOverview      string            `json:\"overview\"`      // 架构概述\n\tModuleSummary map[string]string `json:\"moduleSummary\"` // 模块摘要\n}",
          "purpose": "",
          "range": [
            23,
            26
          ]
        },
        {
          "prototype": "type ProjectContext struct {\n\tProjectName  string              `json:\"projectName\"`  // 项目名称\n\tProjectGoal  string              `json:\"projectGoal\"`  // 项目目标\n\tTechStack    []string            `json:\"techStack\"`    // 技术栈\n\tLastUpdated  time.Time           `json:\"lastUpdated\"`  // 最后更新时间\n\tArchitecture Architecture        `json:\"architecture\"` // 架构信息\n\tFiles        map[string]FileInfo `json:\"files\"`        // 文件信息映射\n}",
          "purpose": "",
          "range": [
            29,
            36
          ]
        },
        {
          "prototype": "type LanguageConfig struct {\n\tExtensions []string `json:\"extensions\"` // 文件扩展名列表\n\tQueries    Queries  `json:\"queries\"`    // 查询规则\n}",
          "purpose": "",
          "range": [
            39,
            42
          ]
        },
        {
          "prototype": "type Queries struct {\n\tTopLevelSymbols  []string `json:\"top_level_symbols\"` // 顶级符号查询\n\tContainerBody    string   `json:\"container_body\"`    // 容器主体查询\n\tContainerMethods string   `json:\"container_methods\"` // 容器方法查询\n}",
          "purpose": "",
          "range": [
            45,
            49
          ]
        },
        {
          "prototype": "type LanguagesConfig map[string]LanguageConfig",
          "purpose": "",
          "range": [
            52,
            52
          ]
        }
      ],
      "lastModified": "2025-09-21T21:31:11+08:00",
      "fileSize": 2222
    },
    "internal\\parser\\simple_parser.go": {
      "purpose": "TODO: Describe the purpose of this file.",
      "symbols": [
        {
          "prototype": "func NewSimpleParser(languagesConfig models.LanguagesConfig) *SimpleParser {\n\treturn \u0026SimpleParser{\n\t\tlanguagesConfig: languagesConfig,\n\t}\n}",
          "purpose": "",
          "range": [
            22,
            26
          ]
        },
        {
          "prototype": "func min(a, b int) int {\n\tif a \u003c b {\n\t\treturn a\n\t}\n\treturn b\n}",
          "purpose": "",
          "range": [
            369,
            374
          ]
        },
        {
          "prototype": "func (p *SimpleParser) ParseFile(filePath string) (*models.FileInfo, error) {\n\t// 获取文件扩展名\n\text := filepath.Ext(filePath)\n\n\t// 查找对应的语言配置\n\tlangName, _, found := config.GetLanguageByExtension(p.languagesConfig, ext)\n\tif !found {\n\t\treturn nil, fmt.Errorf(\"不支持的文件类型: %s\", ext)\n\t}\n\n\t// 获取文件信息\n\tfileInfo, err := os.Stat(filePath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"获取文件信息失败: %w\", err)\n\t}\n\n\t// 读取文件内容\n\tcontent, err := os.ReadFile(filePath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"读取文件失败: %w\", err)\n\t}\n\n\t// 根据语言类型解析符号\n\tsymbols, err := p.parseSymbolsByLanguage(string(content), langName)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"解析符号失败: %w\", err)\n\t}\n\n\treturn \u0026models.FileInfo{\n\t\tPurpose:      p.extractFilePurpose(string(content), langName),\n\t\tSymbols:      symbols,\n\t\tLastModified: fileInfo.ModTime().Format(time.RFC3339),\n\t\tFileSize:     fileInfo.Size(),\n\t}, nil\n}",
          "purpose": "",
          "range": [
            29,
            63
          ]
        },
        {
          "prototype": "func (p *SimpleParser) parseSymbolsByLanguage(content, language string) ([]models.Symbol, error) {\n\tvar symbols []models.Symbol\n\tlines := strings.Split(content, \"\\n\")\n\n\tswitch language {\n\tcase \"go\":\n\t\tsymbols = p.parseGoSymbols(lines)\n\tcase \"javascript\", \"typescript\":\n\t\tsymbols = p.parseJSSymbols(lines)\n\tcase \"python\":\n\t\tsymbols = p.parsePythonSymbols(lines)\n\tcase \"java\":\n\t\tsymbols = p.parseJavaSymbols(lines)\n\tdefault:\n\t\t// 通用解析逻辑\n\t\tsymbols = p.parseGenericSymbols(lines)\n\t}\n\n\treturn symbols, nil\n}",
          "purpose": "",
          "range": [
            66,
            85
          ]
        },
        {
          "prototype": "func (p *SimpleParser) parseGoSymbols(lines []string) []models.Symbol {\n\tvar symbols []models.Symbol\n\n\t// 正则表达式模式\n\tpatterns := map[string]*regexp.Regexp{\n\t\t\"function\": regexp.MustCompile(`^func\\s+(\\w+)?(\\([^)]*\\))?\\s*(\\([^)]*\\))?\\s*(\\w.*)?{?`),\n\t\t\"method\":   regexp.MustCompile(`^func\\s+\\([^)]+\\)\\s+(\\w+)\\s*\\([^)]*\\)\\s*(\\w.*)?{?`),\n\t\t\"type\":     regexp.MustCompile(`^type\\s+(\\w+)\\s+(struct|interface|[^{]+)`),\n\t\t\"const\":    regexp.MustCompile(`^const\\s+(\\w+).*`),\n\t\t\"var\":      regexp.MustCompile(`^var\\s+(\\w+).*`),\n\t}\n\n\tfor i, line := range lines {\n\t\ttrimmed := strings.TrimSpace(line)\n\t\tif trimmed == \"\" || strings.HasPrefix(trimmed, \"//\") {\n\t\t\tcontinue\n\t\t}\n\n\t\tfor symbolType, pattern := range patterns {\n\t\t\tif matches := pattern.FindStringSubmatch(trimmed); len(matches) \u003e 1 {\n\t\t\t\tpurpose := p.extractPurpose(lines, i)\n\n\t\t\t\tsymbol := models.Symbol{\n\t\t\t\t\tPrototype: trimmed,\n\t\t\t\t\tPurpose:   purpose,\n\t\t\t\t\tRange:     []int{i + 1, i + 1}, // 简化的行号范围\n\t\t\t\t}\n\n\t\t\t\t// 对于struct和interface，尝试提取body\n\t\t\t\tif symbolType == \"type\" \u0026\u0026 (strings.Contains(trimmed, \"struct\") || strings.Contains(trimmed, \"interface\")) {\n\t\t\t\t\tbody, endLine := p.extractGoTypeBody(lines, i)\n\t\t\t\t\tsymbol.Body = body\n\t\t\t\t\tsymbol.Range[1] = endLine\n\t\t\t\t}\n\n\t\t\t\tsymbols = append(symbols, symbol)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn symbols\n}",
          "purpose": "",
          "range": [
            88,
            130
          ]
        },
        {
          "prototype": "func (p *SimpleParser) parseJSSymbols(lines []string) []models.Symbol {\n\tvar symbols []models.Symbol\n\n\tpatterns := map[string]*regexp.Regexp{\n\t\t\"function\":  regexp.MustCompile(`^(export\\s+)?(async\\s+)?function\\s+(\\w+)`),\n\t\t\"arrow\":     regexp.MustCompile(`^(const|let|var)\\s+(\\w+)\\s*=\\s*(async\\s+)?\\([^)]*\\)\\s*=\u003e`),\n\t\t\"class\":     regexp.MustCompile(`^(export\\s+)?(abstract\\s+)?class\\s+(\\w+)`),\n\t\t\"interface\": regexp.MustCompile(`^(export\\s+)?interface\\s+(\\w+)`),\n\t}\n\n\tfor i, line := range lines {\n\t\ttrimmed := strings.TrimSpace(line)\n\t\tif trimmed == \"\" || strings.HasPrefix(trimmed, \"//\") {\n\t\t\tcontinue\n\t\t}\n\n\t\tfor _, pattern := range patterns {\n\t\t\tif matches := pattern.FindStringSubmatch(trimmed); len(matches) \u003e 1 {\n\t\t\t\tpurpose := p.extractPurpose(lines, i)\n\n\t\t\t\tsymbol := models.Symbol{\n\t\t\t\t\tPrototype: trimmed,\n\t\t\t\t\tPurpose:   purpose,\n\t\t\t\t\tRange:     []int{i + 1, i + 1},\n\t\t\t\t}\n\n\t\t\t\tsymbols = append(symbols, symbol)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn symbols\n}",
          "purpose": "",
          "range": [
            133,
            166
          ]
        },
        {
          "prototype": "func (p *SimpleParser) parsePythonSymbols(lines []string) []models.Symbol {\n\tvar symbols []models.Symbol\n\n\tpatterns := map[string]*regexp.Regexp{\n\t\t\"function\": regexp.MustCompile(`^def\\s+(\\w+)\\s*\\(`),\n\t\t\"class\":    regexp.MustCompile(`^class\\s+(\\w+).*:`),\n\t}\n\n\tfor i, line := range lines {\n\t\ttrimmed := strings.TrimSpace(line)\n\t\tif trimmed == \"\" || strings.HasPrefix(trimmed, \"#\") {\n\t\t\tcontinue\n\t\t}\n\n\t\tfor _, pattern := range patterns {\n\t\t\tif matches := pattern.FindStringSubmatch(trimmed); len(matches) \u003e 1 {\n\t\t\t\tpurpose := p.extractPurpose(lines, i)\n\n\t\t\t\tsymbol := models.Symbol{\n\t\t\t\t\tPrototype: trimmed,\n\t\t\t\t\tPurpose:   purpose,\n\t\t\t\t\tRange:     []int{i + 1, i + 1},\n\t\t\t\t}\n\n\t\t\t\tsymbols = append(symbols, symbol)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn symbols\n}",
          "purpose": "",
          "range": [
            169,
            200
          ]
        },
        {
          "prototype": "func (p *SimpleParser) parseJavaSymbols(lines []string) []models.Symbol {\n\tvar symbols []models.Symbol\n\n\tpatterns := map[string]*regexp.Regexp{\n\t\t\"method\":    regexp.MustCompile(`^\\s*(public|private|protected).*\\s+(\\w+)\\s*\\(`),\n\t\t\"class\":     regexp.MustCompile(`^\\s*(public\\s+)?(abstract\\s+)?class\\s+(\\w+)`),\n\t\t\"interface\": regexp.MustCompile(`^\\s*(public\\s+)?interface\\s+(\\w+)`),\n\t}\n\n\tfor i, line := range lines {\n\t\ttrimmed := strings.TrimSpace(line)\n\t\tif trimmed == \"\" || strings.HasPrefix(trimmed, \"//\") {\n\t\t\tcontinue\n\t\t}\n\n\t\tfor _, pattern := range patterns {\n\t\t\tif matches := pattern.FindStringSubmatch(trimmed); len(matches) \u003e 1 {\n\t\t\t\tpurpose := p.extractPurpose(lines, i)\n\n\t\t\t\tsymbol := models.Symbol{\n\t\t\t\t\tPrototype: trimmed,\n\t\t\t\t\tPurpose:   purpose,\n\t\t\t\t\tRange:     []int{i + 1, i + 1},\n\t\t\t\t}\n\n\t\t\t\tsymbols = append(symbols, symbol)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn symbols\n}",
          "purpose": "",
          "range": [
            203,
            235
          ]
        },
        {
          "prototype": "func (p *SimpleParser) parseGenericSymbols(lines []string) []models.Symbol {\n\tvar symbols []models.Symbol\n\n\t// 简单的通用模式：查找看起来像函数或类定义的行\n\tpatterns := []*regexp.Regexp{\n\t\tregexp.MustCompile(`^\\w+.*\\([^)]*\\).*{?`),             // 函数模式\n\t\tregexp.MustCompile(`^(class|struct|interface)\\s+\\w+`), // 类型定义模式\n\t}\n\n\tfor i, line := range lines {\n\t\ttrimmed := strings.TrimSpace(line)\n\t\tif trimmed == \"\" || len(trimmed) \u003c 3 {\n\t\t\tcontinue\n\t\t}\n\n\t\tfor _, pattern := range patterns {\n\t\t\tif pattern.MatchString(trimmed) {\n\t\t\t\tsymbol := models.Symbol{\n\t\t\t\t\tPrototype: trimmed,\n\t\t\t\t\tPurpose:   \"Generic symbol detected\",\n\t\t\t\t\tRange:     []int{i + 1, i + 1},\n\t\t\t\t}\n\t\t\t\tsymbols = append(symbols, symbol)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn symbols\n}",
          "purpose": "",
          "range": [
            238,
            267
          ]
        },
        {
          "prototype": "func (p *SimpleParser) extractPurpose(lines []string, currentLine int) string {\n\t// 向上查找注释\n\tfor i := currentLine - 1; i \u003e= 0 \u0026\u0026 i \u003e= currentLine-3; i-- {\n\t\tline := strings.TrimSpace(lines[i])\n\t\tif line == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Go注释\n\t\tif strings.HasPrefix(line, \"//\") {\n\t\t\treturn strings.TrimSpace(strings.TrimPrefix(line, \"//\"))\n\t\t}\n\n\t\t// Python注释\n\t\tif strings.HasPrefix(line, \"#\") {\n\t\t\treturn strings.TrimSpace(strings.TrimPrefix(line, \"#\"))\n\t\t}\n\n\t\t// 其他语言的注释暂时不处理\n\t\tbreak\n\t}\n\n\treturn \"\"\n}",
          "purpose": "",
          "range": [
            270,
            293
          ]
        },
        {
          "prototype": "func (p *SimpleParser) extractGoTypeBody(lines []string, startLine int) (string, int) {\n\tvar bodyLines []string\n\tbraceCount := 0\n\tstarted := false\n\n\tfor i := startLine; i \u003c len(lines); i++ {\n\t\tline := lines[i]\n\n\t\t// 计算大括号\n\t\tfor _, char := range line {\n\t\t\tif char == '{' {\n\t\t\t\tbraceCount++\n\t\t\t\tstarted = true\n\t\t\t} else if char == '}' {\n\t\t\t\tbraceCount--\n\t\t\t}\n\t\t}\n\n\t\t// 如果已经开始并且找到了内容\n\t\tif started \u0026\u0026 braceCount \u003e 0 {\n\t\t\t// 提取大括号内的内容\n\t\t\tif strings.Contains(line, \"{\") {\n\t\t\t\tparts := strings.Split(line, \"{\")\n\t\t\t\tif len(parts) \u003e 1 {\n\t\t\t\t\tbodyLines = append(bodyLines, parts[1])\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbodyLines = append(bodyLines, line)\n\t\t\t}\n\t\t}\n\n\t\t// 如果大括号闭合，结束\n\t\tif started \u0026\u0026 braceCount == 0 {\n\t\t\treturn strings.Join(bodyLines, \"\\n\"), i + 1\n\t\t}\n\t}\n\n\treturn strings.Join(bodyLines, \"\\n\"), len(lines)\n}",
          "purpose": "",
          "range": [
            296,
            334
          ]
        },
        {
          "prototype": "func (p *SimpleParser) extractFilePurpose(content, language string) string {\n\tlines := strings.Split(content, \"\\n\")\n\n\t// 查找文件顶部的注释\n\tfor _, line := range lines[:min(10, len(lines))] {\n\t\ttrimmed := strings.TrimSpace(line)\n\n\t\t// 跳过package声明等\n\t\tif strings.HasPrefix(trimmed, \"package\") ||\n\t\t\tstrings.HasPrefix(trimmed, \"import\") ||\n\t\t\ttrimmed == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t// 查找注释\n\t\tif strings.HasPrefix(trimmed, \"//\") {\n\t\t\tpurpose := strings.TrimSpace(strings.TrimPrefix(trimmed, \"//\"))\n\t\t\tif len(purpose) \u003e 10 { // 过滤太短的注释\n\t\t\t\treturn purpose\n\t\t\t}\n\t\t}\n\n\t\t// 如果遇到代码行，停止查找\n\t\tif !strings.HasPrefix(trimmed, \"//\") \u0026\u0026 !strings.HasPrefix(trimmed, \"#\") {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn \"TODO: Describe the purpose of this file.\"\n}",
          "purpose": "",
          "range": [
            337,
            366
          ]
        },
        {
          "prototype": "type SimpleParser struct {\n\tlanguagesConfig models.LanguagesConfig\n}",
          "purpose": "",
          "range": [
            17,
            19
          ]
        },
        {
          "prototype": "var symbols []models.Symbol",
          "purpose": "",
          "range": [
            67,
            67
          ]
        },
        {
          "prototype": "var symbols []models.Symbol",
          "purpose": "",
          "range": [
            89,
            89
          ]
        },
        {
          "prototype": "var symbols []models.Symbol",
          "purpose": "",
          "range": [
            134,
            134
          ]
        },
        {
          "prototype": "var symbols []models.Symbol",
          "purpose": "",
          "range": [
            170,
            170
          ]
        },
        {
          "prototype": "var symbols []models.Symbol",
          "purpose": "",
          "range": [
            204,
            204
          ]
        },
        {
          "prototype": "var symbols []models.Symbol",
          "purpose": "",
          "range": [
            239,
            239
          ]
        },
        {
          "prototype": "var bodyLines []string",
          "purpose": "",
          "range": [
            297,
            297
          ]
        }
      ],
      "lastModified": "2025-10-07T16:36:19+08:00",
      "fileSize": 9614
    },
    "internal\\parser\\simple_parser_test.go": {
      "purpose": "TODO: Describe the purpose of this file.",
      "symbols": [
        {
          "prototype": "func TestNewSimpleParser(t *testing.T) {\r\n\tconfig := models.LanguagesConfig{\r\n\t\t\"go\": {\r\n\t\t\tExtensions: []string{\".go\"},\r\n\t\t},\r\n\t}\r\n\r\n\tparser := NewSimpleParser(config)\r\n\tassert.NotNil(t, parser)\r\n\tassert.Equal(t, config, parser.languagesConfig)\r\n}",
          "purpose": "",
          "range": [
            13,
            23
          ]
        },
        {
          "prototype": "func TestParseGoFile(t *testing.T) {\r\n\tparser := NewSimpleParser(getTestConfig())\r\n\r\n\t// 创建临时测试文件\r\n\ttmpFile := createTempFile(t, \"test.go\", goTestCode)\r\n\tdefer os.Remove(tmpFile)\r\n\r\n\tresult, err := parser.ParseFile(tmpFile)\r\n\r\n\trequire.NoError(t, err)\r\n\trequire.NotNil(t, result)\r\n\r\n\t// 验证符号数量\r\n\tassert.GreaterOrEqual(t, len(result.Symbols), 1)\r\n\r\n\t// 验证第一个符号\r\n\tif len(result.Symbols) \u003e 0 {\r\n\t\tsymbol := result.Symbols[0]\r\n\t\tassert.NotEmpty(t, symbol.Prototype)\r\n\t\tassert.NotEmpty(t, symbol.Range)\r\n\t\tassert.Equal(t, 2, len(symbol.Range))\r\n\t}\r\n}",
          "purpose": "",
          "range": [
            25,
            47
          ]
        },
        {
          "prototype": "func TestParseGoSymbols(t *testing.T) {\r\n\tparser := NewSimpleParser(getTestConfig())\r\n\r\n\tlines := []string{\r\n\t\t\"package main\",\r\n\t\t\"\",\r\n\t\t\"// main 函数\",\r\n\t\t\"func main() {\",\r\n\t\t\"    fmt.Println(\\\"Hello\\\")\",\r\n\t\t\"}\",\r\n\t}\r\n\r\n\tsymbols := parser.parseGoSymbols(lines)\r\n\r\n\tassert.Equal(t, 1, len(symbols))\r\n\tassert.Contains(t, symbols[0].Prototype, \"func main()\")\r\n\tassert.Equal(t, \"main 函数\", symbols[0].Purpose)\r\n}",
          "purpose": "",
          "range": [
            49,
            66
          ]
        },
        {
          "prototype": "func TestParseJSSymbols(t *testing.T) {\r\n\tparser := NewSimpleParser(getTestConfig())\r\n\r\n\tlines := []string{\r\n\t\t\"// 用户类\",\r\n\t\t\"class User {\",\r\n\t\t\"    constructor(name) {\",\r\n\t\t\"        this.name = name;\",\r\n\t\t\"    }\",\r\n\t\t\"}\",\r\n\t}\r\n\r\n\tsymbols := parser.parseJSSymbols(lines)\r\n\r\n\tassert.GreaterOrEqual(t, len(symbols), 1)\r\n}",
          "purpose": "",
          "range": [
            68,
            83
          ]
        },
        {
          "prototype": "func TestParsePythonSymbols(t *testing.T) {\r\n\tparser := NewSimpleParser(getTestConfig())\r\n\r\n\tlines := []string{\r\n\t\t\"# 用户类\",\r\n\t\t\"class User:\",\r\n\t\t\"    def __init__(self, name):\",\r\n\t\t\"        self.name = name\",\r\n\t}\r\n\r\n\tsymbols := parser.parsePythonSymbols(lines)\r\n\r\n\tassert.GreaterOrEqual(t, len(symbols), 1)\r\n}",
          "purpose": "",
          "range": [
            85,
            98
          ]
        },
        {
          "prototype": "func TestExtractPurpose(t *testing.T) {\r\n\tparser := NewSimpleParser(getTestConfig())\r\n\r\n\ttestCases := []struct {\r\n\t\tname     string\r\n\t\tlines    []string\r\n\t\tlineNum  int\r\n\t\texpected string\r\n\t}{\r\n\t\t{\r\n\t\t\tname: \"Go单行注释\",\r\n\t\t\tlines: []string{\r\n\t\t\t\t\"// 这是一个测试函数\",\r\n\t\t\t\t\"func test() {}\",\r\n\t\t\t},\r\n\t\t\tlineNum:  1,\r\n\t\t\texpected: \"这是一个测试函数\",\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"Python注释\",\r\n\t\t\tlines: []string{\r\n\t\t\t\t\"# 这是Python函数\",\r\n\t\t\t\t\"def test():\",\r\n\t\t\t},\r\n\t\t\tlineNum:  1,\r\n\t\t\texpected: \"这是Python函数\",\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"无注释\",\r\n\t\t\tlines: []string{\r\n\t\t\t\t\"func test() {}\",\r\n\t\t\t},\r\n\t\t\tlineNum:  0,\r\n\t\t\texpected: \"\",\r\n\t\t},\r\n\t}\r\n\r\n\tfor _, tc := range testCases {\r\n\t\tt.Run(tc.name, func(t *testing.T) {\r\n\t\t\tresult := parser.extractPurpose(tc.lines, tc.lineNum)\r\n\t\t\tassert.Equal(t, tc.expected, result)\r\n\t\t})\r\n\t}\r\n}",
          "purpose": "",
          "range": [
            100,
            143
          ]
        },
        {
          "prototype": "func TestExtractFilePurpose(t *testing.T) {\r\n\tparser := NewSimpleParser(getTestConfig())\r\n\r\n\t// 测试有注释的文件\r\n\tcontentWithComment := `package main\r\n\r\n// 这是一个测试程序\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n    fmt.Println(\"Hello\")\r\n}`\r\n\r\n\tpurpose := parser.extractFilePurpose(contentWithComment, \"go\")\r\n\tassert.Contains(t, purpose, \"测试程序\")\r\n\r\n\t// 测试无注释的文件\r\n\tcontentWithoutComment := `package main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n    fmt.Println(\"Hello\")\r\n}`\r\n\r\n\tpurpose = parser.extractFilePurpose(contentWithoutComment, \"go\")\r\n\tassert.Equal(t, \"TODO: Describe the purpose of this file.\", purpose)\r\n}",
          "purpose": "",
          "range": [
            145,
            172
          ]
        },
        {
          "prototype": "func TestParseFileWithUnsupportedExtension(t *testing.T) {\r\n\tparser := NewSimpleParser(getTestConfig())\r\n\r\n\t// 创建临时测试文件\r\n\ttmpFile := createTempFile(t, \"test.txt\", \"some content\")\r\n\tdefer os.Remove(tmpFile)\r\n\r\n\t_, err := parser.ParseFile(tmpFile)\r\n\tassert.Error(t, err)\r\n\tassert.Contains(t, err.Error(), \"不支持的文件类型\")\r\n}",
          "purpose": "",
          "range": [
            174,
            184
          ]
        },
        {
          "prototype": "func TestParseFileNotFound(t *testing.T) {\r\n\tparser := NewSimpleParser(getTestConfig())\r\n\r\n\t_, err := parser.ParseFile(\"nonexistent.go\")\r\n\tassert.Error(t, err)\r\n\tassert.Contains(t, err.Error(), \"获取文件信息失败\")\r\n}",
          "purpose": "",
          "range": [
            186,
            192
          ]
        },
        {
          "prototype": "func getTestConfig() models.LanguagesConfig {\r\n\treturn models.LanguagesConfig{\r\n\t\t\"go\": {\r\n\t\t\tExtensions: []string{\".go\"},\r\n\t\t},\r\n\t\t\"javascript\": {\r\n\t\t\tExtensions: []string{\".js\", \".jsx\"},\r\n\t\t},\r\n\t\t\"python\": {\r\n\t\t\tExtensions: []string{\".py\"},\r\n\t\t},\r\n\t}\r\n}",
          "purpose": "",
          "range": [
            196,
            208
          ]
        },
        {
          "prototype": "func createTempFile(t *testing.T, name, content string) string {\r\n\ttmpFile := filepath.Join(t.TempDir(), name)\r\n\terr := os.WriteFile(tmpFile, []byte(content), 0644)\r\n\trequire.NoError(t, err)\r\n\treturn tmpFile\r\n}",
          "purpose": "",
          "range": [
            210,
            215
          ]
        },
        {
          "prototype": "const goTestCode = `package main\r\n\r\n// main 函数\r\nfunc main() {\r\n    println(\"test\")\r\n}\r\n\r\n// helper 函数\r\nfunc helper() string {\r\n    return \"help\"\r\n}\r\n`",
          "purpose": "",
          "range": [
            217,
            228
          ]
        }
      ],
      "lastModified": "2025-10-07T16:36:19+08:00",
      "fileSize": 4852
    },
    "internal\\parser\\testdata\\example.go": {
      "purpose": "Greeter 是一个简单的问候器",
      "symbols": [
        {
          "prototype": "func NewGreeter(name string) *Greeter {\r\n\treturn \u0026Greeter{Name: name}\r\n}",
          "purpose": "",
          "range": [
            11,
            13
          ]
        },
        {
          "prototype": "func main() {\r\n\tgreeter := NewGreeter(\"CodeCartographer\")\r\n\tmessage := greeter.SayHello(\"World\")\r\n\tfmt.Println(message)\r\n}",
          "purpose": "",
          "range": [
            21,
            25
          ]
        },
        {
          "prototype": "func (g *Greeter) SayHello(person string) string {\r\n\treturn fmt.Sprintf(\"Hello %s, I'm %s!\", person, g.Name)\r\n}",
          "purpose": "",
          "range": [
            16,
            18
          ]
        },
        {
          "prototype": "type Greeter struct {\r\n\tName string\r\n}",
          "purpose": "",
          "range": [
            6,
            8
          ]
        }
      ],
      "lastModified": "2025-10-07T16:36:19+08:00",
      "fileSize": 541
    },
    "internal\\parser\\testdata\\example.js": {
      "purpose": "用户管理模块",
      "symbols": [
        {
          "prototype": "user =\u003e user.id === id",
          "purpose": "",
          "range": [
            20,
            20
          ]
        },
        {
          "prototype": "(id, name, email) =\u003e {\r\n    return new User(id, name, email);\r\n}",
          "purpose": "",
          "range": [
            39,
            41
          ]
        },
        {
          "prototype": "class UserManager {\r\n    constructor() {\r\n        this.users = [];\r\n    }\r\n\r\n    // 添加用户\r\n    addUser(user) {\r\n        this.users.push(user);\r\n        return this.users.length;\r\n    }\r\n\r\n    // 获取所有用户\r\n    getUsers() {\r\n        return [...this.users];\r\n    }\r\n\r\n    // 根据ID查找用户\r\n    findUserById(id) {\r\n        return this.users.find(user =\u003e user.id === id);\r\n    }\r\n}",
          "purpose": "",
          "range": [
            2,
            22
          ]
        },
        {
          "prototype": "class User {\r\n    constructor(id, name, email) {\r\n        this.id = id;\r\n        this.name = name;\r\n        this.email = email;\r\n    }\r\n\r\n    // 获取用户信息\r\n    getInfo() {\r\n        return `${this.name} (${this.email})`;\r\n    }\r\n}",
          "purpose": "",
          "range": [
            25,
            36
          ]
        }
      ],
      "lastModified": "2025-10-07T16:36:17+08:00",
      "fileSize": 858
    },
    "internal\\parser\\testdata\\example.py": {
      "purpose": "TODO: Describe the purpose of this file.",
      "symbols": [
        {
          "prototype": "def __init__(self):\r\n        \"\"\"初始化用户管理器\"\"\"\r\n        self.users = []",
          "purpose": "",
          "range": [
            10,
            12
          ]
        },
        {
          "prototype": "def add_user(self, user):\r\n        \"\"\"添加用户到管理器\r\n        \r\n        Args:\r\n            user: User 实例\r\n            \r\n        Returns:\r\n            int: 用户总数\r\n        \"\"\"\r\n        self.users.append(user)\r\n        return len(self.users)",
          "purpose": "",
          "range": [
            14,
            24
          ]
        },
        {
          "prototype": "def get_users(self):\r\n        \"\"\"获取所有用户\r\n        \r\n        Returns:\r\n            list: 用户列表\r\n        \"\"\"\r\n        return self.users.copy()",
          "purpose": "",
          "range": [
            26,
            32
          ]
        },
        {
          "prototype": "def find_user_by_id(self, user_id):\r\n        \"\"\"根据ID查找用户\r\n        \r\n        Args:\r\n            user_id: 用户ID\r\n            \r\n        Returns:\r\n            User or None: 找到的用户或None\r\n        \"\"\"\r\n        for user in self.users:\r\n            if user.id == user_id:\r\n                return user\r\n        return None",
          "purpose": "",
          "range": [
            34,
            46
          ]
        },
        {
          "prototype": "def __init__(self, user_id, name, email):\r\n        \"\"\"初始化用户\r\n        \r\n        Args:\r\n            user_id: 用户ID\r\n            name: 用户名\r\n            email: 邮箱地址\r\n        \"\"\"\r\n        self.id = user_id\r\n        self.name = name\r\n        self.email = email",
          "purpose": "",
          "range": [
            51,
            61
          ]
        },
        {
          "prototype": "def get_info(self):\r\n        \"\"\"获取用户信息\r\n        \r\n        Returns:\r\n            str: 用户信息字符串\r\n        \"\"\"\r\n        return f\"{self.name} ({self.email})\"",
          "purpose": "",
          "range": [
            63,
            69
          ]
        },
        {
          "prototype": "def create_user(user_id, name, email):\r\n    \"\"\"创建用户实例\r\n    \r\n    Args:\r\n        user_id: 用户ID\r\n        name: 用户名\r\n        email: 邮箱地址\r\n        \r\n    Returns:\r\n        User: 用户实例\r\n    \"\"\"\r\n    return User(user_id, name, email)",
          "purpose": "",
          "range": [
            71,
            82
          ]
        },
        {
          "prototype": "class UserManager:\r\n    \"\"\"用户管理器类\"\"\"\r\n    \r\n    def __init__(self):\r\n        \"\"\"初始化用户管理器\"\"\"\r\n        self.users = []\r\n    \r\n    def add_user(self, user):\r\n        \"\"\"添加用户到管理器\r\n        \r\n        Args:\r\n            user: User 实例\r\n            \r\n        Returns:\r\n            int: 用户总数\r\n        \"\"\"\r\n        self.users.append(user)\r\n        return len(self.users)\r\n    \r\n    def get_users(self):\r\n        \"\"\"获取所有用户\r\n        \r\n        Returns:\r\n            list: 用户列表\r\n        \"\"\"\r\n        return self.users.copy()\r\n    \r\n    def find_user_by_id(self, user_id):\r\n        \"\"\"根据ID查找用户\r\n        \r\n        Args:\r\n            user_id: 用户ID\r\n            \r\n        Returns:\r\n            User or None: 找到的用户或None\r\n        \"\"\"\r\n        for user in self.users:\r\n            if user.id == user_id:\r\n                return user\r\n        return None",
          "purpose": "",
          "range": [
            7,
            46
          ]
        },
        {
          "prototype": "class User:\r\n    \"\"\"用户类\"\"\"\r\n    \r\n    def __init__(self, user_id, name, email):\r\n        \"\"\"初始化用户\r\n        \r\n        Args:\r\n            user_id: 用户ID\r\n            name: 用户名\r\n            email: 邮箱地址\r\n        \"\"\"\r\n        self.id = user_id\r\n        self.name = name\r\n        self.email = email\r\n    \r\n    def get_info(self):\r\n        \"\"\"获取用户信息\r\n        \r\n        Returns:\r\n            str: 用户信息字符串\r\n        \"\"\"\r\n        return f\"{self.name} ({self.email})\"",
          "purpose": "",
          "range": [
            48,
            69
          ]
        },
        {
          "prototype": "self.users = []",
          "purpose": "",
          "range": [
            12,
            12
          ]
        },
        {
          "prototype": "self.id = user_id",
          "purpose": "",
          "range": [
            59,
            59
          ]
        },
        {
          "prototype": "self.name = name",
          "purpose": "",
          "range": [
            60,
            60
          ]
        },
        {
          "prototype": "self.email = email",
          "purpose": "",
          "range": [
            61,
            61
          ]
        }
      ],
      "lastModified": "2025-10-07T16:36:17+08:00",
      "fileSize": 1823
    },
    "internal\\parser\\treesitter_parser.go": {
      "purpose": "TODO: Describe the purpose of this file.",
      "symbols": [
        {
          "prototype": "func NewTreeSitterParser(languagesConfig models.LanguagesConfig) (*TreeSitterParser, error) {\r\n\tp := \u0026TreeSitterParser{\r\n\t\tlanguagesConfig: languagesConfig,\r\n\t\tparsers:         make(map[string]*sitter.Parser),\r\n\t}\r\n\r\n\t// 初始化各语言解析器\r\n\tif err := p.initParsers(); err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn p, nil\r\n}",
          "purpose": "",
          "range": [
            26,
            38
          ]
        },
        {
          "prototype": "func minInt(a, b int) int {\r\n\tif a \u003c b {\r\n\t\treturn a\r\n\t}\r\n\treturn b\r\n}",
          "purpose": "",
          "range": [
            236,
            241
          ]
        },
        {
          "prototype": "func (p *TreeSitterParser) initParsers() error {\r\n\t// Go 语言\r\n\tgoParser := sitter.NewParser()\r\n\tgoParser.SetLanguage(golang.GetLanguage())\r\n\tp.parsers[\"go\"] = goParser\r\n\r\n\t// JavaScript\r\n\tjsParser := sitter.NewParser()\r\n\tjsParser.SetLanguage(javascript.GetLanguage())\r\n\tp.parsers[\"javascript\"] = jsParser\r\n\tp.parsers[\"typescript\"] = jsParser // 暂时共用\r\n\r\n\t// Python\r\n\tpyParser := sitter.NewParser()\r\n\tpyParser.SetLanguage(python.GetLanguage())\r\n\tp.parsers[\"python\"] = pyParser\r\n\r\n\treturn nil\r\n}",
          "purpose": "",
          "range": [
            41,
            59
          ]
        },
        {
          "prototype": "func (p *TreeSitterParser) ParseFile(filePath string) (*models.FileInfo, error) {\r\n\t// 读取文件\r\n\tcontent, err := os.ReadFile(filePath)\r\n\tif err != nil {\r\n\t\treturn nil, fmt.Errorf(\"读取文件失败: %w\", err)\r\n\t}\r\n\r\n\t// 确定语言\r\n\text := filepath.Ext(filePath)\r\n\tlangName, _, found := config.GetLanguageByExtension(p.languagesConfig, ext)\r\n\tif !found {\r\n\t\treturn nil, fmt.Errorf(\"不支持的文件类型: %s\", ext)\r\n\t}\r\n\r\n\t// 为每次解析创建新的解析器实例（tree-sitter 不是线程安全的）\r\n\tparser := sitter.NewParser()\r\n\tvar language *sitter.Language\r\n\tswitch langName {\r\n\tcase \"go\":\r\n\t\tlanguage = golang.GetLanguage()\r\n\tcase \"javascript\", \"typescript\":\r\n\t\tlanguage = javascript.GetLanguage()\r\n\tcase \"python\":\r\n\t\tlanguage = python.GetLanguage()\r\n\tdefault:\r\n\t\treturn nil, fmt.Errorf(\"未找到 %s 语言的解析器\", langName)\r\n\t}\r\n\tparser.SetLanguage(language)\r\n\r\n\t// 使用 defer-recover 捕获可能的 panic\r\n\tvar symbols []models.Symbol\r\n\tvar parseErr error\r\n\t\r\n\tfunc() {\r\n\t\tdefer func() {\r\n\t\t\tif r := recover(); r != nil {\r\n\t\t\t\tparseErr = fmt.Errorf(\"解析文件 %s 时发生错误: %v\", filePath, r)\r\n\t\t\t}\r\n\t\t}()\r\n\r\n\t\t// 解析\r\n\t\ttree := parser.Parse(nil, content)\r\n\t\tif tree == nil {\r\n\t\t\tparseErr = fmt.Errorf(\"解析失败: tree is nil\")\r\n\t\t\treturn\r\n\t\t}\r\n\t\tdefer tree.Close()\r\n\r\n\t\trootNode := tree.RootNode()\r\n\t\tif rootNode == nil {\r\n\t\t\tparseErr = fmt.Errorf(\"解析失败: root node is nil\")\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// 提取符号\r\n\t\tsymbols = p.extractSymbols(rootNode, content, langName)\r\n\t}()\r\n\r\n\tif parseErr != nil {\r\n\t\treturn nil, parseErr\r\n\t}\r\n\r\n\t// 获取文件信息\r\n\tfileInfo, err := os.Stat(filePath)\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn \u0026models.FileInfo{\r\n\t\tPurpose:      p.extractFilePurpose(content),\r\n\t\tSymbols:      symbols,\r\n\t\tLastModified: fileInfo.ModTime().Format(time.RFC3339),\r\n\t\tFileSize:     fileInfo.Size(),\r\n\t}, nil\r\n}",
          "purpose": "",
          "range": [
            62,
            136
          ]
        },
        {
          "prototype": "func (p *TreeSitterParser) extractSymbols(node *sitter.Node, content []byte, lang string) []models.Symbol {\r\n\tvar symbols []models.Symbol\r\n\r\n\t// 获取查询规则\r\n\tlangConfig, exists := p.languagesConfig[lang]\r\n\tif !exists {\r\n\t\treturn symbols\r\n\t}\r\n\r\n\tqueries := langConfig.Queries.TopLevelSymbols\r\n\r\n\t// 获取语言对象\r\n\tvar language *sitter.Language\r\n\tswitch lang {\r\n\tcase \"go\":\r\n\t\tlanguage = golang.GetLanguage()\r\n\tcase \"javascript\", \"typescript\":\r\n\t\tlanguage = javascript.GetLanguage()\r\n\tcase \"python\":\r\n\t\tlanguage = python.GetLanguage()\r\n\tdefault:\r\n\t\treturn symbols\r\n\t}\r\n\r\n\tfor _, queryStr := range queries {\r\n\t\tquery, err := sitter.NewQuery([]byte(queryStr), language)\r\n\t\tif err != nil {\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tdefer query.Close()\r\n\r\n\t\tcursor := sitter.NewQueryCursor()\r\n\t\tdefer cursor.Close()\r\n\r\n\t\tcursor.Exec(query, node)\r\n\r\n\t\tfor {\r\n\t\t\tmatch, ok := cursor.NextMatch()\r\n\t\t\tif !ok {\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\r\n\t\t\tfor _, capture := range match.Captures {\r\n\t\t\t\tsymbol := p.nodeToSymbol(capture.Node, content)\r\n\t\t\t\tsymbols = append(symbols, symbol)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn symbols\r\n}",
          "purpose": "",
          "range": [
            139,
            189
          ]
        },
        {
          "prototype": "func (p *TreeSitterParser) nodeToSymbol(node *sitter.Node, content []byte) models.Symbol {\r\n\tstart := node.StartPoint()\r\n\tend := node.EndPoint()\r\n\r\n\treturn models.Symbol{\r\n\t\tPrototype: string(content[node.StartByte():node.EndByte()]),\r\n\t\tPurpose:   \"\", // TODO: 从注释提取\r\n\t\tRange:     []int{int(start.Row) + 1, int(end.Row) + 1},\r\n\t}\r\n}",
          "purpose": "",
          "range": [
            192,
            201
          ]
        },
        {
          "prototype": "func (p *TreeSitterParser) extractFilePurpose(content []byte) string {\r\n\tlines := strings.Split(string(content), \"\\n\")\r\n\r\n\t// 查找文件顶部的注释\r\n\tfor _, line := range lines[:minInt(10, len(lines))] {\r\n\t\ttrimmed := strings.TrimSpace(line)\r\n\r\n\t\t// 跳过package声明等\r\n\t\tif strings.HasPrefix(trimmed, \"package\") ||\r\n\t\t\tstrings.HasPrefix(trimmed, \"import\") ||\r\n\t\t\ttrimmed == \"\" {\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t\t// 查找注释\r\n\t\tif strings.HasPrefix(trimmed, \"//\") {\r\n\t\t\tpurpose := strings.TrimSpace(strings.TrimPrefix(trimmed, \"//\"))\r\n\t\t\tif len(purpose) \u003e 10 { // 过滤太短的注释\r\n\t\t\t\treturn purpose\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// 如果遇到代码行，停止查找\r\n\t\tif !strings.HasPrefix(trimmed, \"//\") \u0026\u0026 !strings.HasPrefix(trimmed, \"#\") {\r\n\t\t\tbreak\r\n\t\t}\r\n\t}\r\n\r\n\treturn \"TODO: Describe the purpose of this file.\"\r\n}",
          "purpose": "",
          "range": [
            204,
            233
          ]
        },
        {
          "prototype": "type TreeSitterParser struct {\r\n\tlanguagesConfig models.LanguagesConfig\r\n\tparsers         map[string]*sitter.Parser\r\n}",
          "purpose": "",
          "range": [
            20,
            23
          ]
        },
        {
          "prototype": "var language *sitter.Language",
          "purpose": "",
          "range": [
            78,
            78
          ]
        },
        {
          "prototype": "var symbols []models.Symbol",
          "purpose": "",
          "range": [
            92,
            92
          ]
        },
        {
          "prototype": "var parseErr error",
          "purpose": "",
          "range": [
            93,
            93
          ]
        },
        {
          "prototype": "var symbols []models.Symbol",
          "purpose": "",
          "range": [
            140,
            140
          ]
        },
        {
          "prototype": "var language *sitter.Language",
          "purpose": "",
          "range": [
            151,
            151
          ]
        }
      ],
      "lastModified": "2025-10-07T17:10:48+08:00",
      "fileSize": 5947
    },
    "internal\\scanner\\scanner.go": {
      "purpose": "TODO: Describe the purpose of this file.",
      "symbols": [
        {
          "prototype": "func NewScanner(parser FileParser, excludePatterns []string) *Scanner {\r\n\treturn \u0026Scanner{\r\n\t\tparser:          parser,\r\n\t\texcludePatterns: excludePatterns,\r\n\t}\r\n}",
          "purpose": "",
          "range": [
            25,
            30
          ]
        },
        {
          "prototype": "func contains(slice []string, item string) bool {\r\n\tfor _, s := range slice {\r\n\t\tif s == item {\r\n\t\t\treturn true\r\n\t\t}\r\n\t}\r\n\treturn false\r\n}",
          "purpose": "",
          "range": [
            237,
            244
          ]
        },
        {
          "prototype": "func (s *Scanner) ScanProject(projectPath string) (map[string]models.FileInfo, []string, error) {\r\n\tfiles := make(map[string]models.FileInfo)\r\n\tvar techStack []string\r\n\tvar mu sync.Mutex\r\n\tvar wg sync.WaitGroup\r\n\r\n\t// 用于收集错误的channel\r\n\terrorChan := make(chan error, 100)\r\n\tvar scanErrors []error\r\n\r\n\t// 启动错误收集goroutine\r\n\tgo func() {\r\n\t\tfor err := range errorChan {\r\n\t\t\tscanErrors = append(scanErrors, err)\r\n\t\t}\r\n\t}()\r\n\r\n\t// 遍历项目文件\r\n\terr := filepath.Walk(projectPath, func(path string, info os.FileInfo, err error) error {\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\r\n\t\t// 跳过目录\r\n\t\tif info.IsDir() {\r\n\t\t\t// 检查是否是排除的目录\r\n\t\t\tif s.shouldExclude(path) {\r\n\t\t\t\treturn filepath.SkipDir\r\n\t\t\t}\r\n\t\t\treturn nil\r\n\t\t}\r\n\r\n\t\t// 跳过排除的文件\r\n\t\tif s.shouldExclude(path) {\r\n\t\t\treturn nil\r\n\t\t}\r\n\r\n\t\t// 检查文件扩展名\r\n\t\text := filepath.Ext(path)\r\n\t\tif ext == \"\" {\r\n\t\t\treturn nil\r\n\t\t}\r\n\r\n\t\t// 获取相对路径\r\n\t\trelPath, err := filepath.Rel(projectPath, path)\r\n\t\tif err != nil {\r\n\t\t\trelPath = path\r\n\t\t}\r\n\r\n\t\t// 并发解析文件\r\n\t\twg.Add(1)\r\n\t\tgo func(filePath, relativePath string) {\r\n\t\t\tdefer wg.Done()\r\n\r\n\t\t\tfileInfo, err := s.parser.ParseFile(filePath)\r\n\t\t\tif err != nil {\r\n\t\t\t\terrorChan \u003c- fmt.Errorf(\"解析文件 %s 失败: %w\", relativePath, err)\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\r\n\t\t\t// 安全地更新结果\r\n\t\t\tmu.Lock()\r\n\t\t\tfiles[relativePath] = *fileInfo\r\n\r\n\t\t\t// 收集技术栈信息\r\n\t\t\tlang := s.getLanguageFromExtension(ext)\r\n\t\t\tif lang != \"\" \u0026\u0026 !contains(techStack, lang) {\r\n\t\t\t\ttechStack = append(techStack, lang)\r\n\t\t\t}\r\n\t\t\tmu.Unlock()\r\n\t\t}(path, relPath)\r\n\r\n\t\treturn nil\r\n\t})\r\n\r\n\t// 等待所有goroutine完成\r\n\twg.Wait()\r\n\tclose(errorChan)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, nil, fmt.Errorf(\"扫描项目失败: %w\", err)\r\n\t}\r\n\r\n\t// 如果有扫描错误，记录但不中断\r\n\tif len(scanErrors) \u003e 0 {\r\n\t\tfmt.Printf(\"警告: 扫描过程中遇到 %d 个错误:\\n\", len(scanErrors))\r\n\t\tfor i, err := range scanErrors {\r\n\t\t\tif i \u003c 5 { // 只显示前5个错误\r\n\t\t\t\tfmt.Printf(\"  - %v\\n\", err)\r\n\t\t\t}\r\n\t\t}\r\n\t\tif len(scanErrors) \u003e 5 {\r\n\t\t\tfmt.Printf(\"  ... 还有 %d 个错误\\n\", len(scanErrors)-5)\r\n\t\t}\r\n\t}\r\n\r\n\treturn files, techStack, nil\r\n}",
          "purpose": "",
          "range": [
            33,
            130
          ]
        },
        {
          "prototype": "func (s *Scanner) shouldExclude(path string) bool {\r\n\t// 默认排除模式\r\n\tdefaultExcludes := []string{\r\n\t\t\".git\",\r\n\t\t\".svn\",\r\n\t\t\".hg\",\r\n\t\t\"node_modules\",\r\n\t\t\"vendor\",\r\n\t\t\".idea\",\r\n\t\t\".vscode\",\r\n\t\t\"__pycache__\",\r\n\t\t\".DS_Store\",\r\n\t\t\"*.tmp\",\r\n\t\t\"*.log\",\r\n\t}\r\n\r\n\t// 合并用户指定的排除模式\r\n\tallExcludes := append(defaultExcludes, s.excludePatterns...)\r\n\r\n\tfor _, pattern := range allExcludes {\r\n\t\t// 简单的模式匹配\r\n\t\tif strings.Contains(path, pattern) {\r\n\t\t\treturn true\r\n\t\t}\r\n\r\n\t\t// 通配符匹配\r\n\t\tif matched, _ := filepath.Match(pattern, filepath.Base(path)); matched {\r\n\t\t\treturn true\r\n\t\t}\r\n\t}\r\n\r\n\treturn false\r\n}",
          "purpose": "",
          "range": [
            133,
            165
          ]
        },
        {
          "prototype": "func (s *Scanner) getLanguageFromExtension(ext string) string {\r\n\tlanguageMap := map[string]string{\r\n\t\t\".go\":         \"Go\",\r\n\t\t\".js\":         \"JavaScript\",\r\n\t\t\".jsx\":        \"JavaScript\",\r\n\t\t\".ts\":         \"TypeScript\",\r\n\t\t\".tsx\":        \"TypeScript\",\r\n\t\t\".py\":         \"Python\",\r\n\t\t\".java\":       \"Java\",\r\n\t\t\".c\":          \"C\",\r\n\t\t\".cpp\":        \"C++\",\r\n\t\t\".cc\":         \"C++\",\r\n\t\t\".cxx\":        \"C++\",\r\n\t\t\".h\":          \"C/C++\",\r\n\t\t\".hpp\":        \"C++\",\r\n\t\t\".cs\":         \"C#\",\r\n\t\t\".php\":        \"PHP\",\r\n\t\t\".rb\":         \"Ruby\",\r\n\t\t\".rs\":         \"Rust\",\r\n\t\t\".swift\":      \"Swift\",\r\n\t\t\".kt\":         \"Kotlin\",\r\n\t\t\".scala\":      \"Scala\",\r\n\t\t\".clj\":        \"Clojure\",\r\n\t\t\".hs\":         \"Haskell\",\r\n\t\t\".ml\":         \"OCaml\",\r\n\t\t\".fs\":         \"F#\",\r\n\t\t\".lua\":        \"Lua\",\r\n\t\t\".r\":          \"R\",\r\n\t\t\".m\":          \"Objective-C\",\r\n\t\t\".mm\":         \"Objective-C++\",\r\n\t\t\".dart\":       \"Dart\",\r\n\t\t\".elm\":        \"Elm\",\r\n\t\t\".ex\":         \"Elixir\",\r\n\t\t\".exs\":        \"Elixir\",\r\n\t\t\".erl\":        \"Erlang\",\r\n\t\t\".hrl\":        \"Erlang\",\r\n\t\t\".sql\":        \"SQL\",\r\n\t\t\".sh\":         \"Shell\",\r\n\t\t\".bash\":       \"Bash\",\r\n\t\t\".zsh\":        \"Zsh\",\r\n\t\t\".fish\":       \"Fish\",\r\n\t\t\".ps1\":        \"PowerShell\",\r\n\t\t\".html\":       \"HTML\",\r\n\t\t\".css\":        \"CSS\",\r\n\t\t\".scss\":       \"SCSS\",\r\n\t\t\".sass\":       \"Sass\",\r\n\t\t\".less\":       \"Less\",\r\n\t\t\".xml\":        \"XML\",\r\n\t\t\".json\":       \"JSON\",\r\n\t\t\".yaml\":       \"YAML\",\r\n\t\t\".yml\":        \"YAML\",\r\n\t\t\".toml\":       \"TOML\",\r\n\t\t\".ini\":        \"INI\",\r\n\t\t\".cfg\":        \"Config\",\r\n\t\t\".conf\":       \"Config\",\r\n\t\t\".md\":         \"Markdown\",\r\n\t\t\".tex\":        \"LaTeX\",\r\n\t\t\".dockerfile\": \"Docker\",\r\n\t\t\".Dockerfile\": \"Docker\",\r\n\t}\r\n\r\n\tif lang, exists := languageMap[ext]; exists {\r\n\t\treturn lang\r\n\t}\r\n\r\n\treturn \"\"\r\n}",
          "purpose": "",
          "range": [
            168,
            234
          ]
        },
        {
          "prototype": "type FileParser interface {\r\n\tParseFile(filePath string) (*models.FileInfo, error)\r\n}",
          "purpose": "",
          "range": [
            14,
            16
          ]
        },
        {
          "prototype": "type Scanner struct {\r\n\tparser          FileParser\r\n\texcludePatterns []string\r\n}",
          "purpose": "",
          "range": [
            19,
            22
          ]
        },
        {
          "prototype": "var techStack []string",
          "purpose": "",
          "range": [
            35,
            35
          ]
        },
        {
          "prototype": "var mu sync.Mutex",
          "purpose": "",
          "range": [
            36,
            36
          ]
        },
        {
          "prototype": "var wg sync.WaitGroup",
          "purpose": "",
          "range": [
            37,
            37
          ]
        },
        {
          "prototype": "var scanErrors []error",
          "purpose": "",
          "range": [
            41,
            41
          ]
        }
      ],
      "lastModified": "2025-10-07T16:36:19+08:00",
      "fileSize": 5541
    },
    "internal\\scanner\\scanner_test.go": {
      "purpose": "TODO: Describe the purpose of this file.",
      "symbols": [
        {
          "prototype": "func TestNewScanner(t *testing.T) {\r\n\tparser := \u0026mockParser{}\r\n\texcludePatterns := []string{\"test\", \"temp\"}\r\n\r\n\tscanner := NewScanner(parser, excludePatterns)\r\n\tassert.NotNil(t, scanner)\r\n\tassert.Equal(t, parser, scanner.parser)\r\n\tassert.Equal(t, excludePatterns, scanner.excludePatterns)\r\n}",
          "purpose": "",
          "range": [
            32,
            40
          ]
        },
        {
          "prototype": "func TestScanProject(t *testing.T) {\r\n\t// 创建临时测试目录\r\n\ttmpDir := t.TempDir()\r\n\r\n\t// 创建测试文件\r\n\tcreateTestFile(t, tmpDir, \"main.go\", goTestCode)\r\n\tcreateTestFile(t, tmpDir, \"helper.js\", jsTestCode)\r\n\tcreateTestFile(t, tmpDir, \"README.md\", \"# Test\")\r\n\r\n\t// 创建子目录\r\n\tsubDir := filepath.Join(tmpDir, \"subdir\")\r\n\tos.MkdirAll(subDir, 0755)\r\n\tcreateTestFile(t, subDir, \"utils.go\", goTestCode)\r\n\r\n\t// 创建解析器\r\n\tparser := \u0026mockParser{}\r\n\tscanner := NewScanner(parser, nil)\r\n\r\n\t// 扫描项目\r\n\tfiles, techStack, err := scanner.ScanProject(tmpDir)\r\n\r\n\trequire.NoError(t, err)\r\n\tassert.NotNil(t, files)\r\n\tassert.NotNil(t, techStack)\r\n\r\n\t// 验证结果\r\n\tassert.GreaterOrEqual(t, len(files), 2) // 至少包含 .go 和 .js 文件\r\n\tassert.Contains(t, techStack, \"Go\")\r\n\tassert.Contains(t, techStack, \"JavaScript\")\r\n}",
          "purpose": "",
          "range": [
            42,
            71
          ]
        },
        {
          "prototype": "func TestScanProjectWithExcludePatterns(t *testing.T) {\r\n\t// 创建临时测试目录\r\n\ttmpDir := t.TempDir()\r\n\r\n\t// 创建测试文件\r\n\tcreateTestFile(t, tmpDir, \"main.go\", goTestCode)\r\n\tcreateTestFile(t, tmpDir, \"test.go\", goTestCode)\r\n\tcreateTestFile(t, tmpDir, \"temp.js\", jsTestCode)\r\n\r\n\t// 创建解析器，排除包含 \"test\" 和 \"temp\" 的文件\r\n\tparser := \u0026mockParser{}\r\n\texcludePatterns := []string{\"test\", \"temp\"}\r\n\tscanner := NewScanner(parser, excludePatterns)\r\n\r\n\t// 扫描项目\r\n\tfiles, _, err := scanner.ScanProject(tmpDir)\r\n\r\n\trequire.NoError(t, err)\r\n\tassert.NotNil(t, files)\r\n\r\n\t// 验证排除的文件不在结果中\r\n\tfor filePath := range files {\r\n\t\tassert.NotContains(t, filePath, \"test\")\r\n\t\tassert.NotContains(t, filePath, \"temp\")\r\n\t}\r\n}",
          "purpose": "",
          "range": [
            73,
            98
          ]
        },
        {
          "prototype": "func TestShouldExclude(t *testing.T) {\r\n\tscanner := \u0026Scanner{}\r\n\r\n\t// 测试默认排除模式\r\n\ttestCases := []struct {\r\n\t\tpath     string\r\n\t\texpected bool\r\n\t}{\r\n\t\t{\".git/config\", true},\r\n\t\t{\"node_modules/package\", true},\r\n\t\t{\"vendor/dependency\", true},\r\n\t\t{\"main.go\", false},\r\n\t\t{\"src/main.go\", false},\r\n\t\t{\".DS_Store\", true},\r\n\t\t{\"temp.log\", true},\r\n\t}\r\n\r\n\tfor _, tc := range testCases {\r\n\t\tt.Run(tc.path, func(t *testing.T) {\r\n\t\t\tresult := scanner.shouldExclude(tc.path)\r\n\t\t\tassert.Equal(t, tc.expected, result)\r\n\t\t})\r\n\t}\r\n}",
          "purpose": "",
          "range": [
            100,
            123
          ]
        },
        {
          "prototype": "func TestShouldExcludeWithCustomPatterns(t *testing.T) {\r\n\texcludePatterns := []string{\"test\", \"temp\"}\r\n\tscanner := NewScanner(\u0026mockParser{}, excludePatterns)\r\n\r\n\ttestCases := []struct {\r\n\t\tpath     string\r\n\t\texpected bool\r\n\t}{\r\n\t\t{\"test.go\", true},\r\n\t\t{\"temp.js\", true},\r\n\t\t{\"main.go\", false},\r\n\t\t{\"src/main.go\", false},\r\n\t\t{\"latest.go\", true}, // 包含 \"test\"\r\n\t}\r\n\r\n\tfor _, tc := range testCases {\r\n\t\tt.Run(tc.path, func(t *testing.T) {\r\n\t\t\tresult := scanner.shouldExclude(tc.path)\r\n\t\t\tassert.Equal(t, tc.expected, result)\r\n\t\t})\r\n\t}\r\n}",
          "purpose": "",
          "range": [
            125,
            146
          ]
        },
        {
          "prototype": "func TestGetLanguageFromExtension(t *testing.T) {\r\n\tscanner := \u0026Scanner{}\r\n\r\n\ttestCases := []struct {\r\n\t\text      string\r\n\t\texpected string\r\n\t}{\r\n\t\t{\".go\", \"Go\"},\r\n\t\t{\".js\", \"JavaScript\"},\r\n\t\t{\".jsx\", \"JavaScript\"},\r\n\t\t{\".ts\", \"TypeScript\"},\r\n\t\t{\".py\", \"Python\"},\r\n\t\t{\".java\", \"Java\"},\r\n\t\t{\".cs\", \"C#\"},\r\n\t\t{\".rs\", \"Rust\"},\r\n\t\t{\".cpp\", \"C++\"},\r\n\t\t{\".c\", \"C\"},\r\n\t\t{\".txt\", \"\"},\r\n\t\t{\"\", \"\"},\r\n\t}\r\n\r\n\tfor _, tc := range testCases {\r\n\t\tt.Run(tc.ext, func(t *testing.T) {\r\n\t\t\tresult := scanner.getLanguageFromExtension(tc.ext)\r\n\t\t\tassert.Equal(t, tc.expected, result)\r\n\t\t})\r\n\t}\r\n}",
          "purpose": "",
          "range": [
            148,
            175
          ]
        },
        {
          "prototype": "func TestContains(t *testing.T) {\r\n\ttestCases := []struct {\r\n\t\tslice    []string\r\n\t\titem     string\r\n\t\texpected bool\r\n\t}{\r\n\t\t{[]string{\"go\", \"js\", \"py\"}, \"go\", true},\r\n\t\t{[]string{\"go\", \"js\", \"py\"}, \"js\", true},\r\n\t\t{[]string{\"go\", \"js\", \"py\"}, \"java\", false},\r\n\t\t{[]string{}, \"go\", false},\r\n\t\t{nil, \"go\", false},\r\n\t}\r\n\r\n\tfor _, tc := range testCases {\r\n\t\tt.Run(tc.item, func(t *testing.T) {\r\n\t\t\tresult := contains(tc.slice, tc.item)\r\n\t\t\tassert.Equal(t, tc.expected, result)\r\n\t\t})\r\n\t}\r\n}",
          "purpose": "",
          "range": [
            177,
            196
          ]
        },
        {
          "prototype": "func TestScanProjectEmptyDirectory(t *testing.T) {\r\n\t// 创建空目录\r\n\ttmpDir := t.TempDir()\r\n\r\n\tparser := \u0026mockParser{}\r\n\tscanner := NewScanner(parser, nil)\r\n\r\n\tfiles, techStack, err := scanner.ScanProject(tmpDir)\r\n\r\n\trequire.NoError(t, err)\r\n\tassert.Empty(t, files)\r\n\tassert.Empty(t, techStack)\r\n}",
          "purpose": "",
          "range": [
            198,
            210
          ]
        },
        {
          "prototype": "func TestScanProjectWithErrors(t *testing.T) {\r\n\t// 创建临时测试目录\r\n\ttmpDir := t.TempDir()\r\n\r\n\t// 创建测试文件\r\n\tcreateTestFile(t, tmpDir, \"main.go\", goTestCode)\r\n\r\n\t// 创建会失败的解析器\r\n\tfailingParser := \u0026failingParser{}\r\n\tscanner := NewScanner(failingParser, nil)\r\n\r\n\t// 扫描项目（应该处理错误但不中断）\r\n\tfiles, techStack, err := scanner.ScanProject(tmpDir)\r\n\r\n\t// 应该成功，但文件可能为空\r\n\trequire.NoError(t, err)\r\n\r\n\t// 检查返回值（允许为 nil 或空）\r\n\t_ = files\r\n\t_ = techStack\r\n}",
          "purpose": "",
          "range": [
            212,
            232
          ]
        },
        {
          "prototype": "func createTestFile(t *testing.T, dir, name, content string) {\r\n\tpath := filepath.Join(dir, name)\r\n\terr := os.WriteFile(path, []byte(content), 0644)\r\n\trequire.NoError(t, err)\r\n}",
          "purpose": "",
          "range": [
            236,
            240
          ]
        },
        {
          "prototype": "func (m *mockParser) ParseFile(filePath string) (*models.FileInfo, error) {\r\n\t// 模拟解析结果\r\n\treturn \u0026models.FileInfo{\r\n\t\tPurpose: \"Mock file\",\r\n\t\tSymbols: []models.Symbol{\r\n\t\t\t{\r\n\t\t\t\tPrototype: \"func mock()\",\r\n\t\t\t\tPurpose:   \"Mock function\",\r\n\t\t\t\tRange:     []int{1, 1},\r\n\t\t\t},\r\n\t\t},\r\n\t\tLastModified: \"2025-10-07T00:00:00Z\",\r\n\t\tFileSize:     100,\r\n\t}, nil\r\n}",
          "purpose": "",
          "range": [
            16,
            30
          ]
        },
        {
          "prototype": "func (f *failingParser) ParseFile(filePath string) (*models.FileInfo, error) {\r\n\treturn nil, assert.AnError\r\n}",
          "purpose": "",
          "range": [
            245,
            247
          ]
        },
        {
          "prototype": "type mockParser struct{}",
          "purpose": "",
          "range": [
            14,
            14
          ]
        },
        {
          "prototype": "type failingParser struct{}",
          "purpose": "",
          "range": [
            243,
            243
          ]
        },
        {
          "prototype": "const goTestCode = `package main\r\n\r\nfunc main() {\r\n    println(\"test\")\r\n}\r\n`",
          "purpose": "",
          "range": [
            249,
            254
          ]
        },
        {
          "prototype": "const jsTestCode = `function test() {\r\n    console.log(\"test\");\r\n}\r\n`",
          "purpose": "",
          "range": [
            256,
            259
          ]
        }
      ],
      "lastModified": "2025-10-07T16:36:19+08:00",
      "fileSize": 6120
    },
    "internal\\updater\\incremental.go": {
      "purpose": "TODO: Describe the purpose of this file.",
      "symbols": [
        {
          "prototype": "func NewIncrementalUpdater(p scanner.FileParser) *IncrementalUpdater {\n\treturn \u0026IncrementalUpdater{\n\t\tparser: p,\n\t}\n}",
          "purpose": "",
          "range": [
            21,
            25
          ]
        },
        {
          "prototype": "func (u *IncrementalUpdater) UpdateProject(contextPath, projectPath string, excludePatterns []string) (*models.ProjectContext, []FileChange, error) {\n\t// 1. 加载现有的项目上下文\n\texistingContext, err := u.loadExistingContext(contextPath)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"加载现有上下文失败: %w\", err)\n\t}\n\n\t// 2. 扫描项目文件，检测变更\n\tchanges, err := u.detectFileChanges(existingContext, projectPath, excludePatterns)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"检测文件变更失败: %w\", err)\n\t}\n\n\t// 3. 如果没有变更，直接返回\n\tif len(changes) == 0 {\n\t\tfmt.Println(\"✅ 没有检测到文件变更\")\n\t\treturn existingContext, changes, nil\n\t}\n\n\t// 4. 应用变更\n\tupdatedContext, err := u.applyChanges(existingContext, changes)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"应用变更失败: %w\", err)\n\t}\n\n\t// 5. 更新时间戳\n\tupdatedContext.LastUpdated = time.Now()\n\n\treturn updatedContext, changes, nil\n}",
          "purpose": "",
          "range": [
            45,
            74
          ]
        },
        {
          "prototype": "func (u *IncrementalUpdater) loadExistingContext(contextPath string) (*models.ProjectContext, error) {\n\tif _, err := os.Stat(contextPath); os.IsNotExist(err) {\n\t\treturn nil, fmt.Errorf(\"上下文文件不存在: %s\", contextPath)\n\t}\n\n\tdata, err := os.ReadFile(contextPath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"读取上下文文件失败: %w\", err)\n\t}\n\n\tvar context models.ProjectContext\n\tif err := json.Unmarshal(data, \u0026context); err != nil {\n\t\treturn nil, fmt.Errorf(\"解析上下文文件失败: %w\", err)\n\t}\n\n\treturn \u0026context, nil\n}",
          "purpose": "",
          "range": [
            77,
            93
          ]
        },
        {
          "prototype": "func (u *IncrementalUpdater) detectFileChanges(context *models.ProjectContext, projectPath string, excludePatterns []string) ([]FileChange, error) {\n\tvar changes []FileChange\n\tcurrentFiles := make(map[string]bool)\n\n\t// 遍历项目文件\n\terr := filepath.Walk(projectPath, func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// 跳过目录\n\t\tif info.IsDir() {\n\t\t\treturn nil\n\t\t}\n\n\t\t// 检查是否应该排除\n\t\tif u.shouldExclude(path, excludePatterns) {\n\t\t\treturn nil\n\t\t}\n\n\t\t// 检查是否为支持的文件类型\n\t\text := filepath.Ext(path)\n\t\tif !u.isSupportedFile(ext) {\n\t\t\treturn nil\n\t\t}\n\n\t\t// 转换为相对路径\n\t\trelPath, err := filepath.Rel(projectPath, path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trelPath = filepath.ToSlash(relPath) // 统一使用斜杠\n\n\t\tcurrentFiles[relPath] = true\n\n\t\t// 检查文件是否存在于上下文中\n\t\texistingFile, exists := context.Files[relPath]\n\t\tif !exists {\n\t\t\t// 新文件\n\t\t\tnewInfo, err := u.parser.ParseFile(path)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tchanges = append(changes, FileChange{\n\t\t\t\tPath:       relPath,\n\t\t\t\tChangeType: FileAdded,\n\t\t\t\tNewInfo:    newInfo,\n\t\t\t})\n\t\t} else {\n\t\t\t// 检查文件是否被修改\n\t\t\tif u.isFileModified(path, \u0026existingFile) {\n\t\t\t\tnewInfo, err := u.parser.ParseFile(path)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tchanges = append(changes, FileChange{\n\t\t\t\t\tPath:       relPath,\n\t\t\t\t\tChangeType: FileModified,\n\t\t\t\t\tOldInfo:    \u0026existingFile,\n\t\t\t\t\tNewInfo:    newInfo,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t})\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// 检查已删除的文件\n\tfor filePath := range context.Files {\n\t\tif !currentFiles[filePath] {\n\t\t\texistingFile := context.Files[filePath]\n\t\t\tchanges = append(changes, FileChange{\n\t\t\t\tPath:       filePath,\n\t\t\t\tChangeType: FileDeleted,\n\t\t\t\tOldInfo:    \u0026existingFile,\n\t\t\t})\n\t\t}\n\t}\n\n\treturn changes, nil\n}",
          "purpose": "",
          "range": [
            96,
            180
          ]
        },
        {
          "prototype": "func (u *IncrementalUpdater) isFileModified(filePath string, existingInfo *models.FileInfo) bool {\n\tfileInfo, err := os.Stat(filePath)\n\tif err != nil {\n\t\treturn true // 如果无法获取文件信息，假设已修改\n\t}\n\n\t// 比较修改时间和文件大小\n\tcurrentModTime := fileInfo.ModTime().Format(time.RFC3339)\n\tcurrentSize := fileInfo.Size()\n\n\treturn currentModTime != existingInfo.LastModified || currentSize != existingInfo.FileSize\n}",
          "purpose": "",
          "range": [
            183,
            194
          ]
        },
        {
          "prototype": "func (u *IncrementalUpdater) applyChanges(context *models.ProjectContext, changes []FileChange) (*models.ProjectContext, error) {\n\t// 创建上下文副本\n\tupdatedContext := *context\n\tupdatedFiles := make(map[string]models.FileInfo)\n\n\t// 复制现有文件\n\tfor path, info := range context.Files {\n\t\tupdatedFiles[path] = info\n\t}\n\n\t// 应用变更\n\tfor _, change := range changes {\n\t\tswitch change.ChangeType {\n\t\tcase FileAdded:\n\t\t\tupdatedFiles[change.Path] = *change.NewInfo\n\t\t\tfmt.Printf(\"➕ 添加文件: %s\\n\", change.Path)\n\t\tcase FileModified:\n\t\t\tupdatedFiles[change.Path] = *change.NewInfo\n\t\t\tfmt.Printf(\"✏️  修改文件: %s\\n\", change.Path)\n\t\tcase FileDeleted:\n\t\t\tdelete(updatedFiles, change.Path)\n\t\t\tfmt.Printf(\"🗑️  删除文件: %s\\n\", change.Path)\n\t\t}\n\t}\n\n\tupdatedContext.Files = updatedFiles\n\n\t// 重新生成模块摘要\n\tupdatedContext.Architecture.ModuleSummary = u.generateModuleSummary(updatedFiles)\n\n\treturn \u0026updatedContext, nil\n}",
          "purpose": "",
          "range": [
            197,
            228
          ]
        },
        {
          "prototype": "func (u *IncrementalUpdater) generateModuleSummary(files map[string]models.FileInfo) map[string]string {\n\tmoduleSummary := make(map[string]string)\n\tmoduleFiles := make(map[string][]string)\n\n\t// 按模块分组文件\n\tfor filePath := range files {\n\t\tdir := filepath.Dir(filePath)\n\t\tif dir == \".\" {\n\t\t\tdir = \"root\"\n\t\t}\n\t\tmoduleFiles[dir] = append(moduleFiles[dir], filepath.Base(filePath))\n\t}\n\n\t// 生成摘要\n\tfor module, fileList := range moduleFiles {\n\t\tif len(fileList) == 1 {\n\t\t\tmoduleSummary[module] = fmt.Sprintf(\"包含 1 个文件: %s\", fileList[0])\n\t\t} else {\n\t\t\tmoduleSummary[module] = fmt.Sprintf(\"包含 %d 个文件: %s\", len(fileList), strings.Join(fileList, \", \"))\n\t\t}\n\t}\n\n\treturn moduleSummary\n}",
          "purpose": "",
          "range": [
            231,
            254
          ]
        },
        {
          "prototype": "func (u *IncrementalUpdater) shouldExclude(path string, excludePatterns []string) bool {\n\tpath = filepath.ToSlash(path)\n\tfor _, pattern := range excludePatterns {\n\t\tif matched, _ := filepath.Match(pattern, path); matched {\n\t\t\treturn true\n\t\t}\n\t\tif strings.Contains(path, pattern) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}",
          "purpose": "",
          "range": [
            257,
            268
          ]
        },
        {
          "prototype": "func (u *IncrementalUpdater) isSupportedFile(ext string) bool {\n\tsupportedExts := []string{\".go\", \".js\", \".jsx\", \".ts\", \".tsx\", \".py\", \".java\", \".cs\", \".rs\", \".cpp\", \".c\", \".h\"}\n\tfor _, supportedExt := range supportedExts {\n\t\tif ext == supportedExt {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}",
          "purpose": "",
          "range": [
            271,
            279
          ]
        },
        {
          "prototype": "type IncrementalUpdater struct {\n\tparser scanner.FileParser\n}",
          "purpose": "",
          "range": [
            16,
            18
          ]
        },
        {
          "prototype": "type FileChangeType int",
          "purpose": "",
          "range": [
            28,
            28
          ]
        },
        {
          "prototype": "type FileChange struct {\n\tPath       string\n\tChangeType FileChangeType\n\tOldInfo    *models.FileInfo\n\tNewInfo    *models.FileInfo\n}",
          "purpose": "",
          "range": [
            37,
            42
          ]
        },
        {
          "prototype": "const (\n\tFileAdded FileChangeType = iota\n\tFileModified\n\tFileDeleted\n)",
          "purpose": "",
          "range": [
            30,
            34
          ]
        },
        {
          "prototype": "var context models.ProjectContext",
          "purpose": "",
          "range": [
            87,
            87
          ]
        },
        {
          "prototype": "var changes []FileChange",
          "purpose": "",
          "range": [
            97,
            97
          ]
        }
      ],
      "lastModified": "2025-10-07T16:36:19+08:00",
      "fileSize": 7294
    }
  }
}