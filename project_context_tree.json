{
  "projectName": "CodeCartographer",
  "projectGoal": "TODO: è¯·åœ¨æ­¤æè¿°é¡¹ç›®ç›®æ ‡å’Œä¸»è¦åŠŸèƒ½",
  "techStack": [
    "Go",
    "JavaScript",
    "Python"
  ],
  "lastUpdated": "2025-10-07T17:11:01.4095429+08:00",
  "architecture": {
    "overview": "TODO: è¯·åœ¨æ­¤æè¿°é¡¹ç›®çš„æ•´ä½“æ¶æ„",
    "moduleSummary": {
      "cmd\\contextgen": "åŒ…å« 1 ä¸ªæ–‡ä»¶: main.go",
      "internal\\cmd": "åŒ…å« 1 ä¸ªæ–‡ä»¶: root.go",
      "internal\\config": "åŒ…å« 2 ä¸ªæ–‡ä»¶ï¼Œä¸»è¦ç”¨äº TODO: è¯·æè¿°æ­¤æ¨¡å—çš„ç”¨é€”",
      "internal\\models": "åŒ…å« 1 ä¸ªæ–‡ä»¶: types.go",
      "internal\\parser": "åŒ…å« 3 ä¸ªæ–‡ä»¶ï¼Œä¸»è¦ç”¨äº TODO: è¯·æè¿°æ­¤æ¨¡å—çš„ç”¨é€”",
      "internal\\parser\\testdata": "åŒ…å« 3 ä¸ªæ–‡ä»¶ï¼Œä¸»è¦ç”¨äº TODO: è¯·æè¿°æ­¤æ¨¡å—çš„ç”¨é€”",
      "internal\\scanner": "åŒ…å« 2 ä¸ªæ–‡ä»¶ï¼Œä¸»è¦ç”¨äº TODO: è¯·æè¿°æ­¤æ¨¡å—çš„ç”¨é€”",
      "internal\\updater": "åŒ…å« 1 ä¸ªæ–‡ä»¶: incremental.go"
    }
  },
  "files": {
    "cmd\\contextgen\\main.go": {
      "purpose": "TODO: Describe the purpose of this file.",
      "symbols": [
        {
          "prototype": "func main() {\n\tif err := cmd.Execute(Version); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"é”™è¯¯: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n}",
          "purpose": "",
          "range": [
            14,
            19
          ]
        },
        {
          "prototype": "var Version = \"v0.1.0\"",
          "purpose": "",
          "range": [
            11,
            11
          ]
        }
      ],
      "lastModified": "2025-10-07T16:36:19+08:00",
      "fileSize": 327
    },
    "internal\\cmd\\root.go": {
      "purpose": "TODO: Describe the purpose of this file.",
      "symbols": [
        {
          "prototype": "func init() {\n\t// æ·»åŠ å­å‘½ä»¤\n\trootCmd.AddCommand(generateCmd)\n\trootCmd.AddCommand(updateCmd)\n\n\t// æ·»åŠ generateå‘½ä»¤è¡Œå‚æ•°\n\tgenerateCmd.Flags().StringVarP(\u0026projectPath, \"path\", \"p\", \".\", \"é¡¹ç›®è·¯å¾„\")\n\tgenerateCmd.Flags().StringVarP(\u0026outputPath, \"output\", \"o\", \"project_context.json\", \"è¾“å‡ºæ–‡ä»¶è·¯å¾„\")\n\tgenerateCmd.Flags().StringVarP(\u0026configPath, \"config\", \"c\", \"\", \"è¯­è¨€é…ç½®æ–‡ä»¶è·¯å¾„\")\n\tgenerateCmd.Flags().StringVarP(\u0026excludeDirs, \"exclude\", \"e\", \"\", \"è¦æ’é™¤çš„ç›®å½•æˆ–æ–‡ä»¶æ¨¡å¼ï¼Œç”¨é€—å·åˆ†éš”\")\n\tgenerateCmd.Flags().BoolVarP(\u0026useTreeSitter, \"treesitter\", \"t\", true, \"ä½¿ç”¨ Tree-sitter è§£æå™¨ï¼ˆé»˜è®¤: trueï¼‰\")\n\n\t// æ·»åŠ updateå‘½ä»¤è¡Œå‚æ•°\n\tupdateCmd.Flags().StringVarP(\u0026projectPath, \"path\", \"p\", \".\", \"é¡¹ç›®è·¯å¾„\")\n\tupdateCmd.Flags().StringVarP(\u0026outputPath, \"output\", \"o\", \"project_context.json\", \"è¾“å‡ºæ–‡ä»¶è·¯å¾„\")\n\tupdateCmd.Flags().StringVarP(\u0026configPath, \"config\", \"c\", \"\", \"è¯­è¨€é…ç½®æ–‡ä»¶è·¯å¾„\")\n\tupdateCmd.Flags().StringVarP(\u0026excludeDirs, \"exclude\", \"e\", \"\", \"è¦æ’é™¤çš„ç›®å½•æˆ–æ–‡ä»¶æ¨¡å¼ï¼Œç”¨é€—å·åˆ†éš”\")\n\tupdateCmd.Flags().BoolVarP(\u0026useTreeSitter, \"treesitter\", \"t\", true, \"ä½¿ç”¨ Tree-sitter è§£æå™¨ï¼ˆé»˜è®¤: trueï¼‰\")\n}",
          "purpose": "",
          "range": [
            55,
            73
          ]
        },
        {
          "prototype": "func Execute(version string) error {\n\t// æ·»åŠ ç‰ˆæœ¬å‘½ä»¤\n\tversionCmd := \u0026cobra.Command{\n\t\tUse:   \"version\",\n\t\tShort: \"æ˜¾ç¤ºç‰ˆæœ¬ä¿¡æ¯\",\n\t\tRun: func(cmd *cobra.Command, args []string) {\n\t\t\tfmt.Printf(\"CodeCartographer %s\\n\", version)\n\t\t\tfmt.Printf(\"Goç‰ˆæœ¬: %s\\n\", runtime.Version())\n\t\t\tfmt.Printf(\"æ“ä½œç³»ç»Ÿ: %s/%s\\n\", runtime.GOOS, runtime.GOARCH)\n\t\t},\n\t}\n\trootCmd.AddCommand(versionCmd)\n\n\treturn rootCmd.Execute()\n}",
          "purpose": "",
          "range": [
            76,
            90
          ]
        },
        {
          "prototype": "func runGenerate(cmd *cobra.Command, args []string) error {\n\tfmt.Println(\"ğŸš€ å¼€å§‹ç”Ÿæˆé¡¹ç›®ä¸Šä¸‹æ–‡...\")\n\n\t// 1. åŠ è½½è¯­è¨€é…ç½®\n\tfmt.Println(\"ğŸ“‹ åŠ è½½è¯­è¨€é…ç½®...\")\n\tlanguagesConfig, err := config.LoadLanguagesConfig(configPath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"åŠ è½½è¯­è¨€é…ç½®å¤±è´¥: %w\", err)\n\t}\n\tfmt.Printf(\"âœ… å·²åŠ è½½ %d ç§è¯­è¨€çš„é…ç½®\\n\", len(languagesConfig))\n\n\t// 2. åˆ›å»ºè§£æå™¨\n\tfmt.Println(\"ğŸ”§ åˆå§‹åŒ–è§£æå™¨...\")\n\tvar codeParser scanner.FileParser\n\tif useTreeSitter {\n\t\tfmt.Println(\"ğŸŒ³ ä½¿ç”¨ Tree-sitter è§£æå™¨\")\n\t\ttreeSitterParser, err := parser.NewTreeSitterParser(languagesConfig)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"âš ï¸  Tree-sitter åˆå§‹åŒ–å¤±è´¥ï¼Œå›é€€åˆ°ç®€å•è§£æå™¨: %v\\n\", err)\n\t\t\tcodeParser = parser.NewSimpleParser(languagesConfig)\n\t\t} else {\n\t\t\tcodeParser = treeSitterParser\n\t\t}\n\t} else {\n\t\tfmt.Println(\"ğŸ“ ä½¿ç”¨ç®€å•æ­£åˆ™è¡¨è¾¾å¼è§£æå™¨\")\n\t\tcodeParser = parser.NewSimpleParser(languagesConfig)\n\t}\n\n\t// 3. è§£ææ’é™¤æ¨¡å¼\n\tvar excludePatterns []string\n\tif excludeDirs != \"\" {\n\t\texcludePatterns = strings.Split(excludeDirs, \",\")\n\t\tfor i, pattern := range excludePatterns {\n\t\t\texcludePatterns[i] = strings.TrimSpace(pattern)\n\t\t}\n\t}\n\n\t// 4. åˆ›å»ºæ‰«æå™¨å¹¶æ‰«æé¡¹ç›®\n\tfmt.Printf(\"ğŸ” æ‰«æé¡¹ç›®: %s\\n\", projectPath)\n\tfileScanner := scanner.NewScanner(codeParser, excludePatterns)\n\tfiles, techStack, err := fileScanner.ScanProject(projectPath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"æ‰«æé¡¹ç›®å¤±è´¥: %w\", err)\n\t}\n\tfmt.Printf(\"âœ… æ‰«æå®Œæˆï¼Œæ‰¾åˆ° %d ä¸ªæ–‡ä»¶\\n\", len(files))\n\n\t// 5. æ„å»ºé¡¹ç›®ä¸Šä¸‹æ–‡\n\tfmt.Println(\"ğŸ“¦ æ„å»ºé¡¹ç›®ä¸Šä¸‹æ–‡...\")\n\tprojectName := filepath.Base(projectPath)\n\tif projectName == \".\" {\n\t\tif cwd, err := os.Getwd(); err == nil {\n\t\t\tprojectName = filepath.Base(cwd)\n\t\t} else {\n\t\t\tprojectName = \"Unknown Project\"\n\t\t}\n\t}\n\n\tcontext := models.ProjectContext{\n\t\tProjectName: projectName,\n\t\tProjectGoal: \"TODO: è¯·åœ¨æ­¤æè¿°é¡¹ç›®ç›®æ ‡å’Œä¸»è¦åŠŸèƒ½\",\n\t\tTechStack:   techStack,\n\t\tLastUpdated: time.Now(),\n\t\tArchitecture: models.Architecture{\n\t\t\tOverview:      \"TODO: è¯·åœ¨æ­¤æè¿°é¡¹ç›®çš„æ•´ä½“æ¶æ„\",\n\t\t\tModuleSummary: generateModuleSummary(files),\n\t\t},\n\t\tFiles: files,\n\t}\n\n\t// 6. ç”ŸæˆJSONæ–‡ä»¶\n\tfmt.Printf(\"ğŸ’¾ ç”Ÿæˆè¾“å‡ºæ–‡ä»¶: %s\\n\", outputPath)\n\terr = saveProjectContext(\u0026context, outputPath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"ä¿å­˜é¡¹ç›®ä¸Šä¸‹æ–‡å¤±è´¥: %w\", err)\n\t}\n\n\t// 7. æ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯\n\tprintStatistics(\u0026context)\n\n\tfmt.Println(\"ğŸ‰ é¡¹ç›®ä¸Šä¸‹æ–‡ç”Ÿæˆå®Œæˆ!\")\n\treturn nil\n}",
          "purpose": "",
          "range": [
            93,
            174
          ]
        },
        {
          "prototype": "func generateModuleSummary(files map[string]models.FileInfo) map[string]string {\n\tmoduleSummary := make(map[string]string)\n\n\t// æŒ‰ç›®å½•åˆ†ç»„æ–‡ä»¶\n\tdirGroups := make(map[string][]string)\n\tfor filePath := range files {\n\t\tdir := filepath.Dir(filePath)\n\t\tif dir == \".\" {\n\t\t\tdir = \"root\"\n\t\t}\n\t\tdirGroups[dir] = append(dirGroups[dir], filePath)\n\t}\n\n\t// ä¸ºæ¯ä¸ªç›®å½•ç”Ÿæˆæ‘˜è¦\n\tfor dir, fileList := range dirGroups {\n\t\tif len(fileList) == 1 {\n\t\t\tmoduleSummary[dir] = fmt.Sprintf(\"åŒ…å« 1 ä¸ªæ–‡ä»¶: %s\", filepath.Base(fileList[0]))\n\t\t} else {\n\t\t\tmoduleSummary[dir] = fmt.Sprintf(\"åŒ…å« %d ä¸ªæ–‡ä»¶ï¼Œä¸»è¦ç”¨äº TODO: è¯·æè¿°æ­¤æ¨¡å—çš„ç”¨é€”\", len(fileList))\n\t\t}\n\t}\n\n\treturn moduleSummary\n}",
          "purpose": "",
          "range": [
            177,
            200
          ]
        },
        {
          "prototype": "func saveProjectContext(context *models.ProjectContext, outputPath string) error {\n\t// åˆ›å»ºè¾“å‡ºç›®å½•ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰\n\tif err := os.MkdirAll(filepath.Dir(outputPath), 0755); err != nil {\n\t\treturn err\n\t}\n\n\t// åºåˆ—åŒ–ä¸ºJSON\n\tdata, err := json.MarshalIndent(context, \"\", \"  \")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// å†™å…¥æ–‡ä»¶\n\treturn os.WriteFile(outputPath, data, 0644)\n}",
          "purpose": "",
          "range": [
            203,
            217
          ]
        },
        {
          "prototype": "func runUpdate(cmd *cobra.Command, args []string) error {\n\tfmt.Println(\"ğŸ”„ å¼€å§‹å¢é‡æ›´æ–°é¡¹ç›®ä¸Šä¸‹æ–‡...\")\n\n\t// 1. åŠ è½½è¯­è¨€é…ç½®\n\tlanguagesConfig, err := config.LoadLanguagesConfig(configPath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"åŠ è½½è¯­è¨€é…ç½®å¤±è´¥: %w\", err)\n\t}\n\n\t// 2. åˆ›å»ºè§£æå™¨\n\tvar fileParser scanner.FileParser\n\tif useTreeSitter {\n\t\tfmt.Println(\"ğŸŒ³ ä½¿ç”¨ Tree-sitter è§£æå™¨\")\n\t\ttreeSitterParser, err := parser.NewTreeSitterParser(languagesConfig)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"âš ï¸  Tree-sitter åˆå§‹åŒ–å¤±è´¥ï¼Œå›é€€åˆ°ç®€å•è§£æå™¨: %v\\n\", err)\n\t\t\tfileParser = parser.NewSimpleParser(languagesConfig)\n\t\t} else {\n\t\t\tfileParser = treeSitterParser\n\t\t}\n\t} else {\n\t\tfmt.Println(\"ğŸ“ ä½¿ç”¨ç®€å•æ­£åˆ™è¡¨è¾¾å¼è§£æå™¨\")\n\t\tfileParser = parser.NewSimpleParser(languagesConfig)\n\t}\n\n\t// 3. åˆ›å»ºå¢é‡æ›´æ–°å™¨\n\tincrementalUpdater := updater.NewIncrementalUpdater(fileParser)\n\n\t// 4. è§£ææ’é™¤æ¨¡å¼\n\tvar excludePatterns []string\n\tif excludeDirs != \"\" {\n\t\texcludePatterns = strings.Split(excludeDirs, \",\")\n\t\tfor i, pattern := range excludePatterns {\n\t\t\texcludePatterns[i] = strings.TrimSpace(pattern)\n\t\t}\n\t}\n\n\t// 5. æ‰§è¡Œå¢é‡æ›´æ–°\n\tupdatedContext, changes, err := incrementalUpdater.UpdateProject(outputPath, projectPath, excludePatterns)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"å¢é‡æ›´æ–°å¤±è´¥: %w\", err)\n\t}\n\n\t// 6. å¦‚æœæœ‰å˜æ›´ï¼Œä¿å­˜æ›´æ–°åçš„ä¸Šä¸‹æ–‡\n\tif len(changes) \u003e 0 {\n\t\tfmt.Printf(\"\\nğŸ“ åº”ç”¨äº† %d ä¸ªæ–‡ä»¶å˜æ›´\\n\", len(changes))\n\n\t\tif err := saveProjectContext(updatedContext, outputPath); err != nil {\n\t\t\treturn fmt.Errorf(\"ä¿å­˜æ›´æ–°åçš„ä¸Šä¸‹æ–‡å¤±è´¥: %w\", err)\n\t\t}\n\n\t\tfmt.Printf(\"ğŸ’¾ æ›´æ–°æ–‡ä»¶: %s\\n\", outputPath)\n\t}\n\n\t// 7. æ‰“å°ç»Ÿè®¡ä¿¡æ¯\n\tprintUpdateStatistics(updatedContext, changes)\n\n\treturn nil\n}",
          "purpose": "",
          "range": [
            220,
            278
          ]
        },
        {
          "prototype": "func printStatistics(context *models.ProjectContext) {\n\tfmt.Println(\"\\nğŸ“Š ç»Ÿè®¡ä¿¡æ¯:\")\n\tfmt.Printf(\"  é¡¹ç›®åç§°: %s\\n\", context.ProjectName)\n\tfmt.Printf(\"  æŠ€æœ¯æ ˆ: %s\\n\", strings.Join(context.TechStack, \", \"))\n\tfmt.Printf(\"  æ–‡ä»¶æ•°é‡: %d\\n\", len(context.Files))\n\tfmt.Printf(\"  æ¨¡å—æ•°é‡: %d\\n\", len(context.Architecture.ModuleSummary))\n\n\t// ç»Ÿè®¡ç¬¦å·æ•°é‡\n\ttotalSymbols := 0\n\tfor _, fileInfo := range context.Files {\n\t\ttotalSymbols += len(fileInfo.Symbols)\n\t}\n\tfmt.Printf(\"  ç¬¦å·æ•°é‡: %d\\n\", totalSymbols)\n\n\tfmt.Printf(\"  æœ€åæ›´æ–°: %s\\n\", context.LastUpdated.Format(\"2006-01-02 15:04:05\"))\n}",
          "purpose": "",
          "range": [
            281,
            296
          ]
        },
        {
          "prototype": "func printUpdateStatistics(context *models.ProjectContext, changes []updater.FileChange) {\n\tfmt.Printf(\"\\nğŸ“Š æ›´æ–°ç»Ÿè®¡:\\n\")\n\n\taddedCount := 0\n\tmodifiedCount := 0\n\tdeletedCount := 0\n\n\tfor _, change := range changes {\n\t\tswitch change.ChangeType {\n\t\tcase updater.FileAdded:\n\t\t\taddedCount++\n\t\tcase updater.FileModified:\n\t\t\tmodifiedCount++\n\t\tcase updater.FileDeleted:\n\t\t\tdeletedCount++\n\t\t}\n\t}\n\n\tif len(changes) \u003e 0 {\n\t\tfmt.Printf(\"  ğŸ“ æ–‡ä»¶å˜æ›´: +%d âœï¸%d ğŸ—‘ï¸%d\\n\", addedCount, modifiedCount, deletedCount)\n\t}\n\n\tfmt.Printf(\"  ğŸ“„ æ€»æ–‡ä»¶æ•°é‡: %d\\n\", len(context.Files))\n\n\t// ç»Ÿè®¡ç¬¦å·æ•°é‡\n\tsymbolCount := 0\n\tfor _, fileInfo := range context.Files {\n\t\tsymbolCount += len(fileInfo.Symbols)\n\t}\n\tfmt.Printf(\"  ğŸ” æ€»ç¬¦å·æ•°é‡: %d\\n\", symbolCount)\n\tfmt.Printf(\"  â° æœ€åæ›´æ–°: %s\\n\", context.LastUpdated.Format(\"2006-01-02 15:04:05\"))\n}",
          "purpose": "",
          "range": [
            299,
            330
          ]
        },
        {
          "prototype": "var (\n\tprojectPath   string\n\toutputPath    string\n\tconfigPath    string\n\texcludeDirs   string\n\tuseTreeSitter bool\n)",
          "purpose": "",
          "range": [
            20,
            26
          ]
        },
        {
          "prototype": "var rootCmd = \u0026cobra.Command{\n\tUse:   \"contextgen\",\n\tShort: \"CodeCartographer - é€šç”¨å‹é¡¹ç›®ä¸Šä¸‹æ–‡ç”Ÿæˆå™¨\",\n\tLong: `CodeCartographer æ˜¯ä¸€ä¸ªé«˜æ€§èƒ½ã€è·¨å¹³å°çš„å‘½ä»¤è¡Œå·¥å…·ï¼Œ\nç”¨äºé€šè¿‡é™æ€åˆ†æä¸ºä»»ä½•å¤æ‚çš„ä»£ç ä»“åº“ç”Ÿæˆç»Ÿä¸€ã€ç®€æ´ä¸”ä¿¡æ¯ä¸°å¯Œçš„ project_context.json æ–‡ä»¶ã€‚\n\næ­¤æ–‡ä»¶å°†ä½œä¸ºå¤§è¯­è¨€æ¨¡å‹ï¼ˆLLMï¼‰çš„\"å…¨å±€ä¸Šä¸‹æ–‡è®°å¿†\"ï¼Œä½¿å…¶èƒ½å¤Ÿä»¥å‰æ‰€æœªæœ‰çš„\nå‡†ç¡®æ€§å’Œæ·±åº¦æ¥ç†è§£é¡¹ç›®æ¶æ„ï¼Œä»è€Œæå‡ä»£ç ç”Ÿæˆã€éœ€æ±‚å˜æ›´ã€é‡æ„å’Œè°ƒè¯•ç­‰ä»»åŠ¡çš„è¡¨ç°ã€‚`,\n}",
          "purpose": "",
          "range": [
            29,
            37
          ]
        },
        {
          "prototype": "var generateCmd = \u0026cobra.Command{\n\tUse:   \"generate\",\n\tShort: \"ç”Ÿæˆé¡¹ç›®ä¸Šä¸‹æ–‡æ–‡ä»¶\",\n\tLong:  `æ‰«ææŒ‡å®šé¡¹ç›®ç›®å½•ï¼Œè§£æä»£ç æ–‡ä»¶ï¼Œå¹¶ç”Ÿæˆ project_context.json æ–‡ä»¶ã€‚`,\n\tRunE:  runGenerate,\n}",
          "purpose": "",
          "range": [
            40,
            45
          ]
        },
        {
          "prototype": "var updateCmd = \u0026cobra.Command{\n\tUse:   \"update\",\n\tShort: \"å¢é‡æ›´æ–°é¡¹ç›®ä¸Šä¸‹æ–‡æ–‡ä»¶\",\n\tLong:  `æ£€æµ‹æ–‡ä»¶å˜æ›´å¹¶å¢é‡æ›´æ–°ç°æœ‰çš„ project_context.json æ–‡ä»¶ï¼Œåªé‡æ–°è§£æå·²ä¿®æ”¹çš„æ–‡ä»¶ã€‚`,\n\tRunE:  runUpdate,\n}",
          "purpose": "",
          "range": [
            48,
            53
          ]
        },
        {
          "prototype": "var codeParser scanner.FileParser",
          "purpose": "",
          "range": [
            106,
            106
          ]
        },
        {
          "prototype": "var excludePatterns []string",
          "purpose": "",
          "range": [
            122,
            122
          ]
        },
        {
          "prototype": "var fileParser scanner.FileParser",
          "purpose": "",
          "range": [
            230,
            230
          ]
        },
        {
          "prototype": "var excludePatterns []string",
          "purpose": "",
          "range": [
            249,
            249
          ]
        }
      ],
      "lastModified": "2025-10-07T16:36:19+08:00",
      "fileSize": 10418
    },
    "internal\\config\\config.go": {
      "purpose": "TODO: Describe the purpose of this file.",
      "symbols": [
        {
          "prototype": "func LoadLanguagesConfig(configPath string) (models.LanguagesConfig, error) {\n\t// å¦‚æœæ²¡æœ‰æŒ‡å®šé…ç½®è·¯å¾„ï¼Œä½¿ç”¨é»˜è®¤è·¯å¾„\n\tif configPath == \"\" {\n\t\tconfigPath = \"languages.json\"\n\t}\n\n\t// æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨\n\tif _, err := os.Stat(configPath); os.IsNotExist(err) {\n\t\t// å¦‚æœé…ç½®æ–‡ä»¶ä¸å­˜åœ¨ï¼Œåˆ›å»ºé»˜è®¤é…ç½®\n\t\treturn createDefaultLanguagesConfig(configPath)\n\t}\n\n\t// è¯»å–é…ç½®æ–‡ä»¶\n\tdata, err := os.ReadFile(configPath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"è¯»å–é…ç½®æ–‡ä»¶å¤±è´¥: %w\", err)\n\t}\n\n\tvar config models.LanguagesConfig\n\tif err := json.Unmarshal(data, \u0026config); err != nil {\n\t\treturn nil, fmt.Errorf(\"è§£æé…ç½®æ–‡ä»¶å¤±è´¥: %w\", err)\n\t}\n\n\treturn config, nil\n}",
          "purpose": "",
          "range": [
            21,
            45
          ]
        },
        {
          "prototype": "func createDefaultLanguagesConfig(configPath string) (models.LanguagesConfig, error) {\n\tdefaultConfig := models.LanguagesConfig{\n\t\t\"go\": {\n\t\t\tExtensions: []string{\".go\"},\n\t\t\tQueries: models.Queries{\n\t\t\t\tTopLevelSymbols: []string{\n\t\t\t\t\t\"(function_declaration) @symbol\",\n\t\t\t\t\t\"(method_declaration) @symbol\",\n\t\t\t\t\t\"(type_declaration) @symbol\",\n\t\t\t\t\t\"(const_declaration) @symbol\",\n\t\t\t\t\t\"(var_declaration) @symbol\",\n\t\t\t\t},\n\t\t\t\tContainerBody:    \"(block) @body | (struct_type) @body | (interface_type) @body\",\n\t\t\t\tContainerMethods: \"(method_declaration) @method\",\n\t\t\t},\n\t\t},\n\t\t\"javascript\": {\n\t\t\tExtensions: []string{\".js\", \".jsx\"},\n\t\t\tQueries: models.Queries{\n\t\t\t\tTopLevelSymbols: []string{\n\t\t\t\t\t\"(function_declaration) @symbol\",\n\t\t\t\t\t\"(arrow_function) @symbol\",\n\t\t\t\t\t\"(class_declaration) @symbol\",\n\t\t\t\t\t\"(const_declaration) @symbol\",\n\t\t\t\t\t\"(let_declaration) @symbol\",\n\t\t\t\t\t\"(var_declaration) @symbol\",\n\t\t\t\t},\n\t\t\t\tContainerBody:    \"(class_body) @body | (object) @body\",\n\t\t\t\tContainerMethods: \"(method_definition) @method\",\n\t\t\t},\n\t\t},\n\t\t\"python\": {\n\t\t\tExtensions: []string{\".py\"},\n\t\t\tQueries: models.Queries{\n\t\t\t\tTopLevelSymbols: []string{\n\t\t\t\t\t\"(function_definition) @symbol\",\n\t\t\t\t\t\"(class_definition) @symbol\",\n\t\t\t\t\t\"(assignment) @symbol\",\n\t\t\t\t},\n\t\t\t\tContainerBody:    \"(block) @body\",\n\t\t\t\tContainerMethods: \"(function_definition) @method\",\n\t\t\t},\n\t\t},\n\t}\n\n\t// åˆ›å»ºé…ç½®æ–‡ä»¶ç›®å½•\n\tif err := os.MkdirAll(filepath.Dir(configPath), 0755); err != nil {\n\t\treturn nil, fmt.Errorf(\"åˆ›å»ºé…ç½®ç›®å½•å¤±è´¥: %w\", err)\n\t}\n\n\t// å†™å…¥é»˜è®¤é…ç½®æ–‡ä»¶\n\tdata, err := json.MarshalIndent(defaultConfig, \"\", \"  \")\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"åºåˆ—åŒ–é»˜è®¤é…ç½®å¤±è´¥: %w\", err)\n\t}\n\n\tif err := os.WriteFile(configPath, data, 0644); err != nil {\n\t\treturn nil, fmt.Errorf(\"å†™å…¥é…ç½®æ–‡ä»¶å¤±è´¥: %w\", err)\n\t}\n\n\tfmt.Printf(\"å·²åˆ›å»ºé»˜è®¤é…ç½®æ–‡ä»¶: %s\\n\", configPath)\n\treturn defaultConfig, nil\n}",
          "purpose": "",
          "range": [
            48,
            110
          ]
        },
        {
          "prototype": "func GetLanguageByExtension(config models.LanguagesConfig, ext string) (string, models.LanguageConfig, bool) {\n\tfor langName, langConfig := range config {\n\t\tfor _, supportedExt := range langConfig.Extensions {\n\t\t\tif supportedExt == ext {\n\t\t\t\treturn langName, langConfig, true\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\", models.LanguageConfig{}, false\n}",
          "purpose": "",
          "range": [
            113,
            122
          ]
        },
        {
          "prototype": "type Config struct {\n\tLanguages   models.LanguagesConfig\n\tOutput      string\n\tExclude     []string\n\tProjectPath string\n}",
          "purpose": "",
          "range": [
            13,
            18
          ]
        },
        {
          "prototype": "var config models.LanguagesConfig",
          "purpose": "",
          "range": [
            39,
            39
          ]
        }
      ],
      "lastModified": "2025-10-07T16:36:19+08:00",
      "fileSize": 3434
    },
    "internal\\config\\config_test.go": {
      "purpose": "TODO: Describe the purpose of this file.",
      "symbols": [
        {
          "prototype": "func TestLoadLanguagesConfig(t *testing.T) {\r\n\t// åˆ›å»ºä¸´æ—¶é…ç½®æ–‡ä»¶\r\n\ttmpDir := t.TempDir()\r\n\tconfigPath := filepath.Join(tmpDir, \"test_languages.json\")\r\n\r\n\t// å†™å…¥æµ‹è¯•é…ç½®\r\n\r\n\tconfigData := `{\r\n\t\t\"go\": {\r\n\t\t\t\"extensions\": [\".go\"],\r\n\t\t\t\"queries\": {\r\n\t\t\t\t\"top_level_symbols\": [\"(function_declaration) @symbol\"]\r\n\t\t\t}\r\n\t\t}\r\n\t}`\r\n\r\n\terr := os.WriteFile(configPath, []byte(configData), 0644)\r\n\trequire.NoError(t, err)\r\n\r\n\t// æµ‹è¯•åŠ è½½é…ç½®\r\n\tconfig, err := LoadLanguagesConfig(configPath)\r\n\trequire.NoError(t, err)\r\n\tassert.NotNil(t, config)\r\n\tassert.Contains(t, config, \"go\")\r\n}",
          "purpose": "",
          "range": [
            13,
            37
          ]
        },
        {
          "prototype": "func TestLoadLanguagesConfigFileNotExist(t *testing.T) {\r\n\t// æµ‹è¯•ä¸å­˜åœ¨çš„é…ç½®æ–‡ä»¶\r\n\ttmpDir := t.TempDir()\r\n\tconfigPath := filepath.Join(tmpDir, \"nonexistent.json\")\r\n\r\n\tconfig, err := LoadLanguagesConfig(configPath)\r\n\trequire.NoError(t, err)\r\n\tassert.NotNil(t, config)\r\n\r\n\t// éªŒè¯é»˜è®¤é…ç½®è¢«åˆ›å»º\r\n\tassert.Contains(t, config, \"go\")\r\n\tassert.Contains(t, config, \"javascript\")\r\n\tassert.Contains(t, config, \"python\")\r\n}",
          "purpose": "",
          "range": [
            39,
            52
          ]
        },
        {
          "prototype": "func TestLoadLanguagesConfigInvalidJSON(t *testing.T) {\r\n\t// åˆ›å»ºæ— æ•ˆçš„JSONæ–‡ä»¶\r\n\ttmpDir := t.TempDir()\r\n\tconfigPath := filepath.Join(tmpDir, \"invalid.json\")\r\n\r\n\tinvalidJSON := `{ invalid json }`\r\n\terr := os.WriteFile(configPath, []byte(invalidJSON), 0644)\r\n\trequire.NoError(t, err)\r\n\r\n\t// æµ‹è¯•åŠ è½½æ— æ•ˆé…ç½®\r\n\t_, err = LoadLanguagesConfig(configPath)\r\n\tassert.Error(t, err)\r\n\tassert.Contains(t, err.Error(), \"è§£æé…ç½®æ–‡ä»¶å¤±è´¥\")\r\n}",
          "purpose": "",
          "range": [
            54,
            67
          ]
        },
        {
          "prototype": "func TestGetLanguageByExtension(t *testing.T) {\r\n\tconfig := models.LanguagesConfig{\r\n\t\t\"go\": {\r\n\t\t\tExtensions: []string{\".go\"},\r\n\t\t},\r\n\t\t\"javascript\": {\r\n\t\t\tExtensions: []string{\".js\", \".jsx\"},\r\n\t\t},\r\n\t}\r\n\r\n\t// æµ‹è¯•å­˜åœ¨çš„æ‰©å±•å\r\n\tlangName, langConfig, found := GetLanguageByExtension(config, \".go\")\r\n\tassert.True(t, found)\r\n\tassert.Equal(t, \"go\", langName)\r\n\tassert.Equal(t, []string{\".go\"}, langConfig.Extensions)\r\n\r\n\t// æµ‹è¯•ä¸å­˜åœ¨çš„æ‰©å±•å\r\n\t_, _, found = GetLanguageByExtension(config, \".py\")\r\n\tassert.False(t, found)\r\n\r\n\t// æµ‹è¯•JavaScriptæ‰©å±•å\r\n\tlangName, langConfig, found = GetLanguageByExtension(config, \".js\")\r\n\tassert.True(t, found)\r\n\tassert.Equal(t, \"javascript\", langName)\r\n\tassert.Equal(t, []string{\".js\", \".jsx\"}, langConfig.Extensions)\r\n}",
          "purpose": "",
          "range": [
            69,
            94
          ]
        },
        {
          "prototype": "func TestCreateDefaultLanguagesConfig(t *testing.T) {\r\n\ttmpDir := t.TempDir()\r\n\tconfigPath := filepath.Join(tmpDir, \"default_languages.json\")\r\n\r\n\tconfig, err := createDefaultLanguagesConfig(configPath)\r\n\trequire.NoError(t, err)\r\n\tassert.NotNil(t, config)\r\n\r\n\t// éªŒè¯é»˜è®¤é…ç½®åŒ…å«é¢„æœŸè¯­è¨€\r\n\tassert.Contains(t, config, \"go\")\r\n\tassert.Contains(t, config, \"javascript\")\r\n\tassert.Contains(t, config, \"python\")\r\n\r\n\t// éªŒè¯é…ç½®æ–‡ä»¶è¢«åˆ›å»º\r\n\t_, err = os.Stat(configPath)\r\n\tassert.NoError(t, err)\r\n\r\n\t// éªŒè¯é…ç½®æ–‡ä»¶å†…å®¹\r\n\tcontent, err := os.ReadFile(configPath)\r\n\trequire.NoError(t, err)\r\n\tassert.Contains(t, string(content), \"go\")\r\n\tassert.Contains(t, string(content), \"javascript\")\r\n}",
          "purpose": "",
          "range": [
            96,
            118
          ]
        },
        {
          "prototype": "func TestCreateDefaultLanguagesConfigDirectoryCreation(t *testing.T) {\r\n\t// æµ‹è¯•åœ¨æ·±å±‚ç›®å½•ä¸­åˆ›å»ºé…ç½®æ–‡ä»¶\r\n\ttmpDir := t.TempDir()\r\n\tdeepDir := filepath.Join(tmpDir, \"deep\", \"nested\", \"directory\")\r\n\tconfigPath := filepath.Join(deepDir, \"languages.json\")\r\n\r\n\tconfig, err := createDefaultLanguagesConfig(configPath)\r\n\trequire.NoError(t, err)\r\n\tassert.NotNil(t, config)\r\n\r\n\t// éªŒè¯ç›®å½•è¢«åˆ›å»º\r\n\t_, err = os.Stat(deepDir)\r\n\tassert.NoError(t, err)\r\n\r\n\t// éªŒè¯é…ç½®æ–‡ä»¶è¢«åˆ›å»º\r\n\t_, err = os.Stat(configPath)\r\n\tassert.NoError(t, err)\r\n}",
          "purpose": "",
          "range": [
            120,
            137
          ]
        },
        {
          "prototype": "func TestConfigStruct(t *testing.T) {\r\n\t// æµ‹è¯•Configç»“æ„ä½“\r\n\tconfig := Config{\r\n\t\tLanguages: models.LanguagesConfig{\r\n\t\t\t\"go\": {\r\n\t\t\t\tExtensions: []string{\".go\"},\r\n\t\t\t},\r\n\t\t},\r\n\t\tOutput:      \"output.json\",\r\n\t\tExclude:     []string{\"node_modules\"},\r\n\t\tProjectPath: \"/path/to/project\",\r\n\t}\r\n\r\n\tassert.NotNil(t, config.Languages)\r\n\tassert.Equal(t, \"output.json\", config.Output)\r\n\tassert.Equal(t, []string{\"node_modules\"}, config.Exclude)\r\n\tassert.Equal(t, \"/path/to/project\", config.ProjectPath)\r\n}",
          "purpose": "",
          "range": [
            139,
            156
          ]
        }
      ],
      "lastModified": "2025-10-07T16:36:19+08:00",
      "fileSize": 4245
    },
    "internal\\models\\types.go": {
      "purpose": "Symbol è¡¨ç¤ºä»£ç ä¸­çš„ä¸€ä¸ªç¬¦å·ï¼ˆå¦‚å‡½æ•°ã€ç»“æ„ä½“ã€å¸¸é‡ç­‰ï¼‰",
      "symbols": [
        {
          "prototype": "type Symbol struct {\n\tPrototype string   `json:\"prototype\"`         // ç¬¦å·çš„å®Œæ•´å£°æ˜è¡Œ\n\tPurpose   string   `json:\"purpose\"`           // ä»æ³¨é‡Šä¸­æå–çš„è¯´æ˜\n\tRange     []int    `json:\"range\"`             // [start_line, end_line]\n\tBody      string   `json:\"body,omitempty\"`    // ç”¨äºç±»/ç»“æ„ä½“/æ¥å£ç­‰å®¹å™¨ç±»å‹çš„å†…éƒ¨å†…å®¹\n\tMethods   []Symbol `json:\"methods,omitempty\"` // ç”¨äºç±»/ç»“æ„ä½“çš„æ–¹æ³•\n}",
          "purpose": "",
          "range": [
            6,
            12
          ]
        },
        {
          "prototype": "type FileInfo struct {\n\tPurpose      string   `json:\"purpose\"`      // æ–‡ä»¶çš„ç”¨é€”æè¿°\n\tSymbols      []Symbol `json:\"symbols\"`      // æ–‡ä»¶ä¸­çš„ç¬¦å·åˆ—è¡¨\n\tLastModified string   `json:\"lastModified\"` // æ–‡ä»¶æœ€åä¿®æ”¹æ—¶é—´\n\tFileSize     int64    `json:\"fileSize\"`     // æ–‡ä»¶å¤§å°\n}",
          "purpose": "",
          "range": [
            15,
            20
          ]
        },
        {
          "prototype": "type Architecture struct {\n\tOverview      string            `json:\"overview\"`      // æ¶æ„æ¦‚è¿°\n\tModuleSummary map[string]string `json:\"moduleSummary\"` // æ¨¡å—æ‘˜è¦\n}",
          "purpose": "",
          "range": [
            23,
            26
          ]
        },
        {
          "prototype": "type ProjectContext struct {\n\tProjectName  string              `json:\"projectName\"`  // é¡¹ç›®åç§°\n\tProjectGoal  string              `json:\"projectGoal\"`  // é¡¹ç›®ç›®æ ‡\n\tTechStack    []string            `json:\"techStack\"`    // æŠ€æœ¯æ ˆ\n\tLastUpdated  time.Time           `json:\"lastUpdated\"`  // æœ€åæ›´æ–°æ—¶é—´\n\tArchitecture Architecture        `json:\"architecture\"` // æ¶æ„ä¿¡æ¯\n\tFiles        map[string]FileInfo `json:\"files\"`        // æ–‡ä»¶ä¿¡æ¯æ˜ å°„\n}",
          "purpose": "",
          "range": [
            29,
            36
          ]
        },
        {
          "prototype": "type LanguageConfig struct {\n\tExtensions []string `json:\"extensions\"` // æ–‡ä»¶æ‰©å±•ååˆ—è¡¨\n\tQueries    Queries  `json:\"queries\"`    // æŸ¥è¯¢è§„åˆ™\n}",
          "purpose": "",
          "range": [
            39,
            42
          ]
        },
        {
          "prototype": "type Queries struct {\n\tTopLevelSymbols  []string `json:\"top_level_symbols\"` // é¡¶çº§ç¬¦å·æŸ¥è¯¢\n\tContainerBody    string   `json:\"container_body\"`    // å®¹å™¨ä¸»ä½“æŸ¥è¯¢\n\tContainerMethods string   `json:\"container_methods\"` // å®¹å™¨æ–¹æ³•æŸ¥è¯¢\n}",
          "purpose": "",
          "range": [
            45,
            49
          ]
        },
        {
          "prototype": "type LanguagesConfig map[string]LanguageConfig",
          "purpose": "",
          "range": [
            52,
            52
          ]
        }
      ],
      "lastModified": "2025-09-21T21:31:11+08:00",
      "fileSize": 2222
    },
    "internal\\parser\\simple_parser.go": {
      "purpose": "TODO: Describe the purpose of this file.",
      "symbols": [
        {
          "prototype": "func NewSimpleParser(languagesConfig models.LanguagesConfig) *SimpleParser {\n\treturn \u0026SimpleParser{\n\t\tlanguagesConfig: languagesConfig,\n\t}\n}",
          "purpose": "",
          "range": [
            22,
            26
          ]
        },
        {
          "prototype": "func min(a, b int) int {\n\tif a \u003c b {\n\t\treturn a\n\t}\n\treturn b\n}",
          "purpose": "",
          "range": [
            369,
            374
          ]
        },
        {
          "prototype": "func (p *SimpleParser) ParseFile(filePath string) (*models.FileInfo, error) {\n\t// è·å–æ–‡ä»¶æ‰©å±•å\n\text := filepath.Ext(filePath)\n\n\t// æŸ¥æ‰¾å¯¹åº”çš„è¯­è¨€é…ç½®\n\tlangName, _, found := config.GetLanguageByExtension(p.languagesConfig, ext)\n\tif !found {\n\t\treturn nil, fmt.Errorf(\"ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹: %s\", ext)\n\t}\n\n\t// è·å–æ–‡ä»¶ä¿¡æ¯\n\tfileInfo, err := os.Stat(filePath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"è·å–æ–‡ä»¶ä¿¡æ¯å¤±è´¥: %w\", err)\n\t}\n\n\t// è¯»å–æ–‡ä»¶å†…å®¹\n\tcontent, err := os.ReadFile(filePath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"è¯»å–æ–‡ä»¶å¤±è´¥: %w\", err)\n\t}\n\n\t// æ ¹æ®è¯­è¨€ç±»å‹è§£æç¬¦å·\n\tsymbols, err := p.parseSymbolsByLanguage(string(content), langName)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"è§£æç¬¦å·å¤±è´¥: %w\", err)\n\t}\n\n\treturn \u0026models.FileInfo{\n\t\tPurpose:      p.extractFilePurpose(string(content), langName),\n\t\tSymbols:      symbols,\n\t\tLastModified: fileInfo.ModTime().Format(time.RFC3339),\n\t\tFileSize:     fileInfo.Size(),\n\t}, nil\n}",
          "purpose": "",
          "range": [
            29,
            63
          ]
        },
        {
          "prototype": "func (p *SimpleParser) parseSymbolsByLanguage(content, language string) ([]models.Symbol, error) {\n\tvar symbols []models.Symbol\n\tlines := strings.Split(content, \"\\n\")\n\n\tswitch language {\n\tcase \"go\":\n\t\tsymbols = p.parseGoSymbols(lines)\n\tcase \"javascript\", \"typescript\":\n\t\tsymbols = p.parseJSSymbols(lines)\n\tcase \"python\":\n\t\tsymbols = p.parsePythonSymbols(lines)\n\tcase \"java\":\n\t\tsymbols = p.parseJavaSymbols(lines)\n\tdefault:\n\t\t// é€šç”¨è§£æé€»è¾‘\n\t\tsymbols = p.parseGenericSymbols(lines)\n\t}\n\n\treturn symbols, nil\n}",
          "purpose": "",
          "range": [
            66,
            85
          ]
        },
        {
          "prototype": "func (p *SimpleParser) parseGoSymbols(lines []string) []models.Symbol {\n\tvar symbols []models.Symbol\n\n\t// æ­£åˆ™è¡¨è¾¾å¼æ¨¡å¼\n\tpatterns := map[string]*regexp.Regexp{\n\t\t\"function\": regexp.MustCompile(`^func\\s+(\\w+)?(\\([^)]*\\))?\\s*(\\([^)]*\\))?\\s*(\\w.*)?{?`),\n\t\t\"method\":   regexp.MustCompile(`^func\\s+\\([^)]+\\)\\s+(\\w+)\\s*\\([^)]*\\)\\s*(\\w.*)?{?`),\n\t\t\"type\":     regexp.MustCompile(`^type\\s+(\\w+)\\s+(struct|interface|[^{]+)`),\n\t\t\"const\":    regexp.MustCompile(`^const\\s+(\\w+).*`),\n\t\t\"var\":      regexp.MustCompile(`^var\\s+(\\w+).*`),\n\t}\n\n\tfor i, line := range lines {\n\t\ttrimmed := strings.TrimSpace(line)\n\t\tif trimmed == \"\" || strings.HasPrefix(trimmed, \"//\") {\n\t\t\tcontinue\n\t\t}\n\n\t\tfor symbolType, pattern := range patterns {\n\t\t\tif matches := pattern.FindStringSubmatch(trimmed); len(matches) \u003e 1 {\n\t\t\t\tpurpose := p.extractPurpose(lines, i)\n\n\t\t\t\tsymbol := models.Symbol{\n\t\t\t\t\tPrototype: trimmed,\n\t\t\t\t\tPurpose:   purpose,\n\t\t\t\t\tRange:     []int{i + 1, i + 1}, // ç®€åŒ–çš„è¡Œå·èŒƒå›´\n\t\t\t\t}\n\n\t\t\t\t// å¯¹äºstructå’Œinterfaceï¼Œå°è¯•æå–body\n\t\t\t\tif symbolType == \"type\" \u0026\u0026 (strings.Contains(trimmed, \"struct\") || strings.Contains(trimmed, \"interface\")) {\n\t\t\t\t\tbody, endLine := p.extractGoTypeBody(lines, i)\n\t\t\t\t\tsymbol.Body = body\n\t\t\t\t\tsymbol.Range[1] = endLine\n\t\t\t\t}\n\n\t\t\t\tsymbols = append(symbols, symbol)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn symbols\n}",
          "purpose": "",
          "range": [
            88,
            130
          ]
        },
        {
          "prototype": "func (p *SimpleParser) parseJSSymbols(lines []string) []models.Symbol {\n\tvar symbols []models.Symbol\n\n\tpatterns := map[string]*regexp.Regexp{\n\t\t\"function\":  regexp.MustCompile(`^(export\\s+)?(async\\s+)?function\\s+(\\w+)`),\n\t\t\"arrow\":     regexp.MustCompile(`^(const|let|var)\\s+(\\w+)\\s*=\\s*(async\\s+)?\\([^)]*\\)\\s*=\u003e`),\n\t\t\"class\":     regexp.MustCompile(`^(export\\s+)?(abstract\\s+)?class\\s+(\\w+)`),\n\t\t\"interface\": regexp.MustCompile(`^(export\\s+)?interface\\s+(\\w+)`),\n\t}\n\n\tfor i, line := range lines {\n\t\ttrimmed := strings.TrimSpace(line)\n\t\tif trimmed == \"\" || strings.HasPrefix(trimmed, \"//\") {\n\t\t\tcontinue\n\t\t}\n\n\t\tfor _, pattern := range patterns {\n\t\t\tif matches := pattern.FindStringSubmatch(trimmed); len(matches) \u003e 1 {\n\t\t\t\tpurpose := p.extractPurpose(lines, i)\n\n\t\t\t\tsymbol := models.Symbol{\n\t\t\t\t\tPrototype: trimmed,\n\t\t\t\t\tPurpose:   purpose,\n\t\t\t\t\tRange:     []int{i + 1, i + 1},\n\t\t\t\t}\n\n\t\t\t\tsymbols = append(symbols, symbol)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn symbols\n}",
          "purpose": "",
          "range": [
            133,
            166
          ]
        },
        {
          "prototype": "func (p *SimpleParser) parsePythonSymbols(lines []string) []models.Symbol {\n\tvar symbols []models.Symbol\n\n\tpatterns := map[string]*regexp.Regexp{\n\t\t\"function\": regexp.MustCompile(`^def\\s+(\\w+)\\s*\\(`),\n\t\t\"class\":    regexp.MustCompile(`^class\\s+(\\w+).*:`),\n\t}\n\n\tfor i, line := range lines {\n\t\ttrimmed := strings.TrimSpace(line)\n\t\tif trimmed == \"\" || strings.HasPrefix(trimmed, \"#\") {\n\t\t\tcontinue\n\t\t}\n\n\t\tfor _, pattern := range patterns {\n\t\t\tif matches := pattern.FindStringSubmatch(trimmed); len(matches) \u003e 1 {\n\t\t\t\tpurpose := p.extractPurpose(lines, i)\n\n\t\t\t\tsymbol := models.Symbol{\n\t\t\t\t\tPrototype: trimmed,\n\t\t\t\t\tPurpose:   purpose,\n\t\t\t\t\tRange:     []int{i + 1, i + 1},\n\t\t\t\t}\n\n\t\t\t\tsymbols = append(symbols, symbol)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn symbols\n}",
          "purpose": "",
          "range": [
            169,
            200
          ]
        },
        {
          "prototype": "func (p *SimpleParser) parseJavaSymbols(lines []string) []models.Symbol {\n\tvar symbols []models.Symbol\n\n\tpatterns := map[string]*regexp.Regexp{\n\t\t\"method\":    regexp.MustCompile(`^\\s*(public|private|protected).*\\s+(\\w+)\\s*\\(`),\n\t\t\"class\":     regexp.MustCompile(`^\\s*(public\\s+)?(abstract\\s+)?class\\s+(\\w+)`),\n\t\t\"interface\": regexp.MustCompile(`^\\s*(public\\s+)?interface\\s+(\\w+)`),\n\t}\n\n\tfor i, line := range lines {\n\t\ttrimmed := strings.TrimSpace(line)\n\t\tif trimmed == \"\" || strings.HasPrefix(trimmed, \"//\") {\n\t\t\tcontinue\n\t\t}\n\n\t\tfor _, pattern := range patterns {\n\t\t\tif matches := pattern.FindStringSubmatch(trimmed); len(matches) \u003e 1 {\n\t\t\t\tpurpose := p.extractPurpose(lines, i)\n\n\t\t\t\tsymbol := models.Symbol{\n\t\t\t\t\tPrototype: trimmed,\n\t\t\t\t\tPurpose:   purpose,\n\t\t\t\t\tRange:     []int{i + 1, i + 1},\n\t\t\t\t}\n\n\t\t\t\tsymbols = append(symbols, symbol)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn symbols\n}",
          "purpose": "",
          "range": [
            203,
            235
          ]
        },
        {
          "prototype": "func (p *SimpleParser) parseGenericSymbols(lines []string) []models.Symbol {\n\tvar symbols []models.Symbol\n\n\t// ç®€å•çš„é€šç”¨æ¨¡å¼ï¼šæŸ¥æ‰¾çœ‹èµ·æ¥åƒå‡½æ•°æˆ–ç±»å®šä¹‰çš„è¡Œ\n\tpatterns := []*regexp.Regexp{\n\t\tregexp.MustCompile(`^\\w+.*\\([^)]*\\).*{?`),             // å‡½æ•°æ¨¡å¼\n\t\tregexp.MustCompile(`^(class|struct|interface)\\s+\\w+`), // ç±»å‹å®šä¹‰æ¨¡å¼\n\t}\n\n\tfor i, line := range lines {\n\t\ttrimmed := strings.TrimSpace(line)\n\t\tif trimmed == \"\" || len(trimmed) \u003c 3 {\n\t\t\tcontinue\n\t\t}\n\n\t\tfor _, pattern := range patterns {\n\t\t\tif pattern.MatchString(trimmed) {\n\t\t\t\tsymbol := models.Symbol{\n\t\t\t\t\tPrototype: trimmed,\n\t\t\t\t\tPurpose:   \"Generic symbol detected\",\n\t\t\t\t\tRange:     []int{i + 1, i + 1},\n\t\t\t\t}\n\t\t\t\tsymbols = append(symbols, symbol)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn symbols\n}",
          "purpose": "",
          "range": [
            238,
            267
          ]
        },
        {
          "prototype": "func (p *SimpleParser) extractPurpose(lines []string, currentLine int) string {\n\t// å‘ä¸ŠæŸ¥æ‰¾æ³¨é‡Š\n\tfor i := currentLine - 1; i \u003e= 0 \u0026\u0026 i \u003e= currentLine-3; i-- {\n\t\tline := strings.TrimSpace(lines[i])\n\t\tif line == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Goæ³¨é‡Š\n\t\tif strings.HasPrefix(line, \"//\") {\n\t\t\treturn strings.TrimSpace(strings.TrimPrefix(line, \"//\"))\n\t\t}\n\n\t\t// Pythonæ³¨é‡Š\n\t\tif strings.HasPrefix(line, \"#\") {\n\t\t\treturn strings.TrimSpace(strings.TrimPrefix(line, \"#\"))\n\t\t}\n\n\t\t// å…¶ä»–è¯­è¨€çš„æ³¨é‡Šæš‚æ—¶ä¸å¤„ç†\n\t\tbreak\n\t}\n\n\treturn \"\"\n}",
          "purpose": "",
          "range": [
            270,
            293
          ]
        },
        {
          "prototype": "func (p *SimpleParser) extractGoTypeBody(lines []string, startLine int) (string, int) {\n\tvar bodyLines []string\n\tbraceCount := 0\n\tstarted := false\n\n\tfor i := startLine; i \u003c len(lines); i++ {\n\t\tline := lines[i]\n\n\t\t// è®¡ç®—å¤§æ‹¬å·\n\t\tfor _, char := range line {\n\t\t\tif char == '{' {\n\t\t\t\tbraceCount++\n\t\t\t\tstarted = true\n\t\t\t} else if char == '}' {\n\t\t\t\tbraceCount--\n\t\t\t}\n\t\t}\n\n\t\t// å¦‚æœå·²ç»å¼€å§‹å¹¶ä¸”æ‰¾åˆ°äº†å†…å®¹\n\t\tif started \u0026\u0026 braceCount \u003e 0 {\n\t\t\t// æå–å¤§æ‹¬å·å†…çš„å†…å®¹\n\t\t\tif strings.Contains(line, \"{\") {\n\t\t\t\tparts := strings.Split(line, \"{\")\n\t\t\t\tif len(parts) \u003e 1 {\n\t\t\t\t\tbodyLines = append(bodyLines, parts[1])\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbodyLines = append(bodyLines, line)\n\t\t\t}\n\t\t}\n\n\t\t// å¦‚æœå¤§æ‹¬å·é—­åˆï¼Œç»“æŸ\n\t\tif started \u0026\u0026 braceCount == 0 {\n\t\t\treturn strings.Join(bodyLines, \"\\n\"), i + 1\n\t\t}\n\t}\n\n\treturn strings.Join(bodyLines, \"\\n\"), len(lines)\n}",
          "purpose": "",
          "range": [
            296,
            334
          ]
        },
        {
          "prototype": "func (p *SimpleParser) extractFilePurpose(content, language string) string {\n\tlines := strings.Split(content, \"\\n\")\n\n\t// æŸ¥æ‰¾æ–‡ä»¶é¡¶éƒ¨çš„æ³¨é‡Š\n\tfor _, line := range lines[:min(10, len(lines))] {\n\t\ttrimmed := strings.TrimSpace(line)\n\n\t\t// è·³è¿‡packageå£°æ˜ç­‰\n\t\tif strings.HasPrefix(trimmed, \"package\") ||\n\t\t\tstrings.HasPrefix(trimmed, \"import\") ||\n\t\t\ttrimmed == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t// æŸ¥æ‰¾æ³¨é‡Š\n\t\tif strings.HasPrefix(trimmed, \"//\") {\n\t\t\tpurpose := strings.TrimSpace(strings.TrimPrefix(trimmed, \"//\"))\n\t\t\tif len(purpose) \u003e 10 { // è¿‡æ»¤å¤ªçŸ­çš„æ³¨é‡Š\n\t\t\t\treturn purpose\n\t\t\t}\n\t\t}\n\n\t\t// å¦‚æœé‡åˆ°ä»£ç è¡Œï¼Œåœæ­¢æŸ¥æ‰¾\n\t\tif !strings.HasPrefix(trimmed, \"//\") \u0026\u0026 !strings.HasPrefix(trimmed, \"#\") {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn \"TODO: Describe the purpose of this file.\"\n}",
          "purpose": "",
          "range": [
            337,
            366
          ]
        },
        {
          "prototype": "type SimpleParser struct {\n\tlanguagesConfig models.LanguagesConfig\n}",
          "purpose": "",
          "range": [
            17,
            19
          ]
        },
        {
          "prototype": "var symbols []models.Symbol",
          "purpose": "",
          "range": [
            67,
            67
          ]
        },
        {
          "prototype": "var symbols []models.Symbol",
          "purpose": "",
          "range": [
            89,
            89
          ]
        },
        {
          "prototype": "var symbols []models.Symbol",
          "purpose": "",
          "range": [
            134,
            134
          ]
        },
        {
          "prototype": "var symbols []models.Symbol",
          "purpose": "",
          "range": [
            170,
            170
          ]
        },
        {
          "prototype": "var symbols []models.Symbol",
          "purpose": "",
          "range": [
            204,
            204
          ]
        },
        {
          "prototype": "var symbols []models.Symbol",
          "purpose": "",
          "range": [
            239,
            239
          ]
        },
        {
          "prototype": "var bodyLines []string",
          "purpose": "",
          "range": [
            297,
            297
          ]
        }
      ],
      "lastModified": "2025-10-07T16:36:19+08:00",
      "fileSize": 9614
    },
    "internal\\parser\\simple_parser_test.go": {
      "purpose": "TODO: Describe the purpose of this file.",
      "symbols": [
        {
          "prototype": "func TestNewSimpleParser(t *testing.T) {\r\n\tconfig := models.LanguagesConfig{\r\n\t\t\"go\": {\r\n\t\t\tExtensions: []string{\".go\"},\r\n\t\t},\r\n\t}\r\n\r\n\tparser := NewSimpleParser(config)\r\n\tassert.NotNil(t, parser)\r\n\tassert.Equal(t, config, parser.languagesConfig)\r\n}",
          "purpose": "",
          "range": [
            13,
            23
          ]
        },
        {
          "prototype": "func TestParseGoFile(t *testing.T) {\r\n\tparser := NewSimpleParser(getTestConfig())\r\n\r\n\t// åˆ›å»ºä¸´æ—¶æµ‹è¯•æ–‡ä»¶\r\n\ttmpFile := createTempFile(t, \"test.go\", goTestCode)\r\n\tdefer os.Remove(tmpFile)\r\n\r\n\tresult, err := parser.ParseFile(tmpFile)\r\n\r\n\trequire.NoError(t, err)\r\n\trequire.NotNil(t, result)\r\n\r\n\t// éªŒè¯ç¬¦å·æ•°é‡\r\n\tassert.GreaterOrEqual(t, len(result.Symbols), 1)\r\n\r\n\t// éªŒè¯ç¬¬ä¸€ä¸ªç¬¦å·\r\n\tif len(result.Symbols) \u003e 0 {\r\n\t\tsymbol := result.Symbols[0]\r\n\t\tassert.NotEmpty(t, symbol.Prototype)\r\n\t\tassert.NotEmpty(t, symbol.Range)\r\n\t\tassert.Equal(t, 2, len(symbol.Range))\r\n\t}\r\n}",
          "purpose": "",
          "range": [
            25,
            47
          ]
        },
        {
          "prototype": "func TestParseGoSymbols(t *testing.T) {\r\n\tparser := NewSimpleParser(getTestConfig())\r\n\r\n\tlines := []string{\r\n\t\t\"package main\",\r\n\t\t\"\",\r\n\t\t\"// main å‡½æ•°\",\r\n\t\t\"func main() {\",\r\n\t\t\"    fmt.Println(\\\"Hello\\\")\",\r\n\t\t\"}\",\r\n\t}\r\n\r\n\tsymbols := parser.parseGoSymbols(lines)\r\n\r\n\tassert.Equal(t, 1, len(symbols))\r\n\tassert.Contains(t, symbols[0].Prototype, \"func main()\")\r\n\tassert.Equal(t, \"main å‡½æ•°\", symbols[0].Purpose)\r\n}",
          "purpose": "",
          "range": [
            49,
            66
          ]
        },
        {
          "prototype": "func TestParseJSSymbols(t *testing.T) {\r\n\tparser := NewSimpleParser(getTestConfig())\r\n\r\n\tlines := []string{\r\n\t\t\"// ç”¨æˆ·ç±»\",\r\n\t\t\"class User {\",\r\n\t\t\"    constructor(name) {\",\r\n\t\t\"        this.name = name;\",\r\n\t\t\"    }\",\r\n\t\t\"}\",\r\n\t}\r\n\r\n\tsymbols := parser.parseJSSymbols(lines)\r\n\r\n\tassert.GreaterOrEqual(t, len(symbols), 1)\r\n}",
          "purpose": "",
          "range": [
            68,
            83
          ]
        },
        {
          "prototype": "func TestParsePythonSymbols(t *testing.T) {\r\n\tparser := NewSimpleParser(getTestConfig())\r\n\r\n\tlines := []string{\r\n\t\t\"# ç”¨æˆ·ç±»\",\r\n\t\t\"class User:\",\r\n\t\t\"    def __init__(self, name):\",\r\n\t\t\"        self.name = name\",\r\n\t}\r\n\r\n\tsymbols := parser.parsePythonSymbols(lines)\r\n\r\n\tassert.GreaterOrEqual(t, len(symbols), 1)\r\n}",
          "purpose": "",
          "range": [
            85,
            98
          ]
        },
        {
          "prototype": "func TestExtractPurpose(t *testing.T) {\r\n\tparser := NewSimpleParser(getTestConfig())\r\n\r\n\ttestCases := []struct {\r\n\t\tname     string\r\n\t\tlines    []string\r\n\t\tlineNum  int\r\n\t\texpected string\r\n\t}{\r\n\t\t{\r\n\t\t\tname: \"Goå•è¡Œæ³¨é‡Š\",\r\n\t\t\tlines: []string{\r\n\t\t\t\t\"// è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•å‡½æ•°\",\r\n\t\t\t\t\"func test() {}\",\r\n\t\t\t},\r\n\t\t\tlineNum:  1,\r\n\t\t\texpected: \"è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•å‡½æ•°\",\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"Pythonæ³¨é‡Š\",\r\n\t\t\tlines: []string{\r\n\t\t\t\t\"# è¿™æ˜¯Pythonå‡½æ•°\",\r\n\t\t\t\t\"def test():\",\r\n\t\t\t},\r\n\t\t\tlineNum:  1,\r\n\t\t\texpected: \"è¿™æ˜¯Pythonå‡½æ•°\",\r\n\t\t},\r\n\t\t{\r\n\t\t\tname: \"æ— æ³¨é‡Š\",\r\n\t\t\tlines: []string{\r\n\t\t\t\t\"func test() {}\",\r\n\t\t\t},\r\n\t\t\tlineNum:  0,\r\n\t\t\texpected: \"\",\r\n\t\t},\r\n\t}\r\n\r\n\tfor _, tc := range testCases {\r\n\t\tt.Run(tc.name, func(t *testing.T) {\r\n\t\t\tresult := parser.extractPurpose(tc.lines, tc.lineNum)\r\n\t\t\tassert.Equal(t, tc.expected, result)\r\n\t\t})\r\n\t}\r\n}",
          "purpose": "",
          "range": [
            100,
            143
          ]
        },
        {
          "prototype": "func TestExtractFilePurpose(t *testing.T) {\r\n\tparser := NewSimpleParser(getTestConfig())\r\n\r\n\t// æµ‹è¯•æœ‰æ³¨é‡Šçš„æ–‡ä»¶\r\n\tcontentWithComment := `package main\r\n\r\n// è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•ç¨‹åº\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n    fmt.Println(\"Hello\")\r\n}`\r\n\r\n\tpurpose := parser.extractFilePurpose(contentWithComment, \"go\")\r\n\tassert.Contains(t, purpose, \"æµ‹è¯•ç¨‹åº\")\r\n\r\n\t// æµ‹è¯•æ— æ³¨é‡Šçš„æ–‡ä»¶\r\n\tcontentWithoutComment := `package main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n    fmt.Println(\"Hello\")\r\n}`\r\n\r\n\tpurpose = parser.extractFilePurpose(contentWithoutComment, \"go\")\r\n\tassert.Equal(t, \"TODO: Describe the purpose of this file.\", purpose)\r\n}",
          "purpose": "",
          "range": [
            145,
            172
          ]
        },
        {
          "prototype": "func TestParseFileWithUnsupportedExtension(t *testing.T) {\r\n\tparser := NewSimpleParser(getTestConfig())\r\n\r\n\t// åˆ›å»ºä¸´æ—¶æµ‹è¯•æ–‡ä»¶\r\n\ttmpFile := createTempFile(t, \"test.txt\", \"some content\")\r\n\tdefer os.Remove(tmpFile)\r\n\r\n\t_, err := parser.ParseFile(tmpFile)\r\n\tassert.Error(t, err)\r\n\tassert.Contains(t, err.Error(), \"ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹\")\r\n}",
          "purpose": "",
          "range": [
            174,
            184
          ]
        },
        {
          "prototype": "func TestParseFileNotFound(t *testing.T) {\r\n\tparser := NewSimpleParser(getTestConfig())\r\n\r\n\t_, err := parser.ParseFile(\"nonexistent.go\")\r\n\tassert.Error(t, err)\r\n\tassert.Contains(t, err.Error(), \"è·å–æ–‡ä»¶ä¿¡æ¯å¤±è´¥\")\r\n}",
          "purpose": "",
          "range": [
            186,
            192
          ]
        },
        {
          "prototype": "func getTestConfig() models.LanguagesConfig {\r\n\treturn models.LanguagesConfig{\r\n\t\t\"go\": {\r\n\t\t\tExtensions: []string{\".go\"},\r\n\t\t},\r\n\t\t\"javascript\": {\r\n\t\t\tExtensions: []string{\".js\", \".jsx\"},\r\n\t\t},\r\n\t\t\"python\": {\r\n\t\t\tExtensions: []string{\".py\"},\r\n\t\t},\r\n\t}\r\n}",
          "purpose": "",
          "range": [
            196,
            208
          ]
        },
        {
          "prototype": "func createTempFile(t *testing.T, name, content string) string {\r\n\ttmpFile := filepath.Join(t.TempDir(), name)\r\n\terr := os.WriteFile(tmpFile, []byte(content), 0644)\r\n\trequire.NoError(t, err)\r\n\treturn tmpFile\r\n}",
          "purpose": "",
          "range": [
            210,
            215
          ]
        },
        {
          "prototype": "const goTestCode = `package main\r\n\r\n// main å‡½æ•°\r\nfunc main() {\r\n    println(\"test\")\r\n}\r\n\r\n// helper å‡½æ•°\r\nfunc helper() string {\r\n    return \"help\"\r\n}\r\n`",
          "purpose": "",
          "range": [
            217,
            228
          ]
        }
      ],
      "lastModified": "2025-10-07T16:36:19+08:00",
      "fileSize": 4852
    },
    "internal\\parser\\testdata\\example.go": {
      "purpose": "Greeter æ˜¯ä¸€ä¸ªç®€å•çš„é—®å€™å™¨",
      "symbols": [
        {
          "prototype": "func NewGreeter(name string) *Greeter {\r\n\treturn \u0026Greeter{Name: name}\r\n}",
          "purpose": "",
          "range": [
            11,
            13
          ]
        },
        {
          "prototype": "func main() {\r\n\tgreeter := NewGreeter(\"CodeCartographer\")\r\n\tmessage := greeter.SayHello(\"World\")\r\n\tfmt.Println(message)\r\n}",
          "purpose": "",
          "range": [
            21,
            25
          ]
        },
        {
          "prototype": "func (g *Greeter) SayHello(person string) string {\r\n\treturn fmt.Sprintf(\"Hello %s, I'm %s!\", person, g.Name)\r\n}",
          "purpose": "",
          "range": [
            16,
            18
          ]
        },
        {
          "prototype": "type Greeter struct {\r\n\tName string\r\n}",
          "purpose": "",
          "range": [
            6,
            8
          ]
        }
      ],
      "lastModified": "2025-10-07T16:36:19+08:00",
      "fileSize": 541
    },
    "internal\\parser\\testdata\\example.js": {
      "purpose": "ç”¨æˆ·ç®¡ç†æ¨¡å—",
      "symbols": [
        {
          "prototype": "user =\u003e user.id === id",
          "purpose": "",
          "range": [
            20,
            20
          ]
        },
        {
          "prototype": "(id, name, email) =\u003e {\r\n    return new User(id, name, email);\r\n}",
          "purpose": "",
          "range": [
            39,
            41
          ]
        },
        {
          "prototype": "class UserManager {\r\n    constructor() {\r\n        this.users = [];\r\n    }\r\n\r\n    // æ·»åŠ ç”¨æˆ·\r\n    addUser(user) {\r\n        this.users.push(user);\r\n        return this.users.length;\r\n    }\r\n\r\n    // è·å–æ‰€æœ‰ç”¨æˆ·\r\n    getUsers() {\r\n        return [...this.users];\r\n    }\r\n\r\n    // æ ¹æ®IDæŸ¥æ‰¾ç”¨æˆ·\r\n    findUserById(id) {\r\n        return this.users.find(user =\u003e user.id === id);\r\n    }\r\n}",
          "purpose": "",
          "range": [
            2,
            22
          ]
        },
        {
          "prototype": "class User {\r\n    constructor(id, name, email) {\r\n        this.id = id;\r\n        this.name = name;\r\n        this.email = email;\r\n    }\r\n\r\n    // è·å–ç”¨æˆ·ä¿¡æ¯\r\n    getInfo() {\r\n        return `${this.name} (${this.email})`;\r\n    }\r\n}",
          "purpose": "",
          "range": [
            25,
            36
          ]
        }
      ],
      "lastModified": "2025-10-07T16:36:17+08:00",
      "fileSize": 858
    },
    "internal\\parser\\testdata\\example.py": {
      "purpose": "TODO: Describe the purpose of this file.",
      "symbols": [
        {
          "prototype": "def __init__(self):\r\n        \"\"\"åˆå§‹åŒ–ç”¨æˆ·ç®¡ç†å™¨\"\"\"\r\n        self.users = []",
          "purpose": "",
          "range": [
            10,
            12
          ]
        },
        {
          "prototype": "def add_user(self, user):\r\n        \"\"\"æ·»åŠ ç”¨æˆ·åˆ°ç®¡ç†å™¨\r\n        \r\n        Args:\r\n            user: User å®ä¾‹\r\n            \r\n        Returns:\r\n            int: ç”¨æˆ·æ€»æ•°\r\n        \"\"\"\r\n        self.users.append(user)\r\n        return len(self.users)",
          "purpose": "",
          "range": [
            14,
            24
          ]
        },
        {
          "prototype": "def get_users(self):\r\n        \"\"\"è·å–æ‰€æœ‰ç”¨æˆ·\r\n        \r\n        Returns:\r\n            list: ç”¨æˆ·åˆ—è¡¨\r\n        \"\"\"\r\n        return self.users.copy()",
          "purpose": "",
          "range": [
            26,
            32
          ]
        },
        {
          "prototype": "def find_user_by_id(self, user_id):\r\n        \"\"\"æ ¹æ®IDæŸ¥æ‰¾ç”¨æˆ·\r\n        \r\n        Args:\r\n            user_id: ç”¨æˆ·ID\r\n            \r\n        Returns:\r\n            User or None: æ‰¾åˆ°çš„ç”¨æˆ·æˆ–None\r\n        \"\"\"\r\n        for user in self.users:\r\n            if user.id == user_id:\r\n                return user\r\n        return None",
          "purpose": "",
          "range": [
            34,
            46
          ]
        },
        {
          "prototype": "def __init__(self, user_id, name, email):\r\n        \"\"\"åˆå§‹åŒ–ç”¨æˆ·\r\n        \r\n        Args:\r\n            user_id: ç”¨æˆ·ID\r\n            name: ç”¨æˆ·å\r\n            email: é‚®ç®±åœ°å€\r\n        \"\"\"\r\n        self.id = user_id\r\n        self.name = name\r\n        self.email = email",
          "purpose": "",
          "range": [
            51,
            61
          ]
        },
        {
          "prototype": "def get_info(self):\r\n        \"\"\"è·å–ç”¨æˆ·ä¿¡æ¯\r\n        \r\n        Returns:\r\n            str: ç”¨æˆ·ä¿¡æ¯å­—ç¬¦ä¸²\r\n        \"\"\"\r\n        return f\"{self.name} ({self.email})\"",
          "purpose": "",
          "range": [
            63,
            69
          ]
        },
        {
          "prototype": "def create_user(user_id, name, email):\r\n    \"\"\"åˆ›å»ºç”¨æˆ·å®ä¾‹\r\n    \r\n    Args:\r\n        user_id: ç”¨æˆ·ID\r\n        name: ç”¨æˆ·å\r\n        email: é‚®ç®±åœ°å€\r\n        \r\n    Returns:\r\n        User: ç”¨æˆ·å®ä¾‹\r\n    \"\"\"\r\n    return User(user_id, name, email)",
          "purpose": "",
          "range": [
            71,
            82
          ]
        },
        {
          "prototype": "class UserManager:\r\n    \"\"\"ç”¨æˆ·ç®¡ç†å™¨ç±»\"\"\"\r\n    \r\n    def __init__(self):\r\n        \"\"\"åˆå§‹åŒ–ç”¨æˆ·ç®¡ç†å™¨\"\"\"\r\n        self.users = []\r\n    \r\n    def add_user(self, user):\r\n        \"\"\"æ·»åŠ ç”¨æˆ·åˆ°ç®¡ç†å™¨\r\n        \r\n        Args:\r\n            user: User å®ä¾‹\r\n            \r\n        Returns:\r\n            int: ç”¨æˆ·æ€»æ•°\r\n        \"\"\"\r\n        self.users.append(user)\r\n        return len(self.users)\r\n    \r\n    def get_users(self):\r\n        \"\"\"è·å–æ‰€æœ‰ç”¨æˆ·\r\n        \r\n        Returns:\r\n            list: ç”¨æˆ·åˆ—è¡¨\r\n        \"\"\"\r\n        return self.users.copy()\r\n    \r\n    def find_user_by_id(self, user_id):\r\n        \"\"\"æ ¹æ®IDæŸ¥æ‰¾ç”¨æˆ·\r\n        \r\n        Args:\r\n            user_id: ç”¨æˆ·ID\r\n            \r\n        Returns:\r\n            User or None: æ‰¾åˆ°çš„ç”¨æˆ·æˆ–None\r\n        \"\"\"\r\n        for user in self.users:\r\n            if user.id == user_id:\r\n                return user\r\n        return None",
          "purpose": "",
          "range": [
            7,
            46
          ]
        },
        {
          "prototype": "class User:\r\n    \"\"\"ç”¨æˆ·ç±»\"\"\"\r\n    \r\n    def __init__(self, user_id, name, email):\r\n        \"\"\"åˆå§‹åŒ–ç”¨æˆ·\r\n        \r\n        Args:\r\n            user_id: ç”¨æˆ·ID\r\n            name: ç”¨æˆ·å\r\n            email: é‚®ç®±åœ°å€\r\n        \"\"\"\r\n        self.id = user_id\r\n        self.name = name\r\n        self.email = email\r\n    \r\n    def get_info(self):\r\n        \"\"\"è·å–ç”¨æˆ·ä¿¡æ¯\r\n        \r\n        Returns:\r\n            str: ç”¨æˆ·ä¿¡æ¯å­—ç¬¦ä¸²\r\n        \"\"\"\r\n        return f\"{self.name} ({self.email})\"",
          "purpose": "",
          "range": [
            48,
            69
          ]
        },
        {
          "prototype": "self.users = []",
          "purpose": "",
          "range": [
            12,
            12
          ]
        },
        {
          "prototype": "self.id = user_id",
          "purpose": "",
          "range": [
            59,
            59
          ]
        },
        {
          "prototype": "self.name = name",
          "purpose": "",
          "range": [
            60,
            60
          ]
        },
        {
          "prototype": "self.email = email",
          "purpose": "",
          "range": [
            61,
            61
          ]
        }
      ],
      "lastModified": "2025-10-07T16:36:17+08:00",
      "fileSize": 1823
    },
    "internal\\parser\\treesitter_parser.go": {
      "purpose": "TODO: Describe the purpose of this file.",
      "symbols": [
        {
          "prototype": "func NewTreeSitterParser(languagesConfig models.LanguagesConfig) (*TreeSitterParser, error) {\r\n\tp := \u0026TreeSitterParser{\r\n\t\tlanguagesConfig: languagesConfig,\r\n\t\tparsers:         make(map[string]*sitter.Parser),\r\n\t}\r\n\r\n\t// åˆå§‹åŒ–å„è¯­è¨€è§£æå™¨\r\n\tif err := p.initParsers(); err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn p, nil\r\n}",
          "purpose": "",
          "range": [
            26,
            38
          ]
        },
        {
          "prototype": "func minInt(a, b int) int {\r\n\tif a \u003c b {\r\n\t\treturn a\r\n\t}\r\n\treturn b\r\n}",
          "purpose": "",
          "range": [
            236,
            241
          ]
        },
        {
          "prototype": "func (p *TreeSitterParser) initParsers() error {\r\n\t// Go è¯­è¨€\r\n\tgoParser := sitter.NewParser()\r\n\tgoParser.SetLanguage(golang.GetLanguage())\r\n\tp.parsers[\"go\"] = goParser\r\n\r\n\t// JavaScript\r\n\tjsParser := sitter.NewParser()\r\n\tjsParser.SetLanguage(javascript.GetLanguage())\r\n\tp.parsers[\"javascript\"] = jsParser\r\n\tp.parsers[\"typescript\"] = jsParser // æš‚æ—¶å…±ç”¨\r\n\r\n\t// Python\r\n\tpyParser := sitter.NewParser()\r\n\tpyParser.SetLanguage(python.GetLanguage())\r\n\tp.parsers[\"python\"] = pyParser\r\n\r\n\treturn nil\r\n}",
          "purpose": "",
          "range": [
            41,
            59
          ]
        },
        {
          "prototype": "func (p *TreeSitterParser) ParseFile(filePath string) (*models.FileInfo, error) {\r\n\t// è¯»å–æ–‡ä»¶\r\n\tcontent, err := os.ReadFile(filePath)\r\n\tif err != nil {\r\n\t\treturn nil, fmt.Errorf(\"è¯»å–æ–‡ä»¶å¤±è´¥: %w\", err)\r\n\t}\r\n\r\n\t// ç¡®å®šè¯­è¨€\r\n\text := filepath.Ext(filePath)\r\n\tlangName, _, found := config.GetLanguageByExtension(p.languagesConfig, ext)\r\n\tif !found {\r\n\t\treturn nil, fmt.Errorf(\"ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹: %s\", ext)\r\n\t}\r\n\r\n\t// ä¸ºæ¯æ¬¡è§£æåˆ›å»ºæ–°çš„è§£æå™¨å®ä¾‹ï¼ˆtree-sitter ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼‰\r\n\tparser := sitter.NewParser()\r\n\tvar language *sitter.Language\r\n\tswitch langName {\r\n\tcase \"go\":\r\n\t\tlanguage = golang.GetLanguage()\r\n\tcase \"javascript\", \"typescript\":\r\n\t\tlanguage = javascript.GetLanguage()\r\n\tcase \"python\":\r\n\t\tlanguage = python.GetLanguage()\r\n\tdefault:\r\n\t\treturn nil, fmt.Errorf(\"æœªæ‰¾åˆ° %s è¯­è¨€çš„è§£æå™¨\", langName)\r\n\t}\r\n\tparser.SetLanguage(language)\r\n\r\n\t// ä½¿ç”¨ defer-recover æ•è·å¯èƒ½çš„ panic\r\n\tvar symbols []models.Symbol\r\n\tvar parseErr error\r\n\t\r\n\tfunc() {\r\n\t\tdefer func() {\r\n\t\t\tif r := recover(); r != nil {\r\n\t\t\t\tparseErr = fmt.Errorf(\"è§£ææ–‡ä»¶ %s æ—¶å‘ç”Ÿé”™è¯¯: %v\", filePath, r)\r\n\t\t\t}\r\n\t\t}()\r\n\r\n\t\t// è§£æ\r\n\t\ttree := parser.Parse(nil, content)\r\n\t\tif tree == nil {\r\n\t\t\tparseErr = fmt.Errorf(\"è§£æå¤±è´¥: tree is nil\")\r\n\t\t\treturn\r\n\t\t}\r\n\t\tdefer tree.Close()\r\n\r\n\t\trootNode := tree.RootNode()\r\n\t\tif rootNode == nil {\r\n\t\t\tparseErr = fmt.Errorf(\"è§£æå¤±è´¥: root node is nil\")\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// æå–ç¬¦å·\r\n\t\tsymbols = p.extractSymbols(rootNode, content, langName)\r\n\t}()\r\n\r\n\tif parseErr != nil {\r\n\t\treturn nil, parseErr\r\n\t}\r\n\r\n\t// è·å–æ–‡ä»¶ä¿¡æ¯\r\n\tfileInfo, err := os.Stat(filePath)\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\treturn \u0026models.FileInfo{\r\n\t\tPurpose:      p.extractFilePurpose(content),\r\n\t\tSymbols:      symbols,\r\n\t\tLastModified: fileInfo.ModTime().Format(time.RFC3339),\r\n\t\tFileSize:     fileInfo.Size(),\r\n\t}, nil\r\n}",
          "purpose": "",
          "range": [
            62,
            136
          ]
        },
        {
          "prototype": "func (p *TreeSitterParser) extractSymbols(node *sitter.Node, content []byte, lang string) []models.Symbol {\r\n\tvar symbols []models.Symbol\r\n\r\n\t// è·å–æŸ¥è¯¢è§„åˆ™\r\n\tlangConfig, exists := p.languagesConfig[lang]\r\n\tif !exists {\r\n\t\treturn symbols\r\n\t}\r\n\r\n\tqueries := langConfig.Queries.TopLevelSymbols\r\n\r\n\t// è·å–è¯­è¨€å¯¹è±¡\r\n\tvar language *sitter.Language\r\n\tswitch lang {\r\n\tcase \"go\":\r\n\t\tlanguage = golang.GetLanguage()\r\n\tcase \"javascript\", \"typescript\":\r\n\t\tlanguage = javascript.GetLanguage()\r\n\tcase \"python\":\r\n\t\tlanguage = python.GetLanguage()\r\n\tdefault:\r\n\t\treturn symbols\r\n\t}\r\n\r\n\tfor _, queryStr := range queries {\r\n\t\tquery, err := sitter.NewQuery([]byte(queryStr), language)\r\n\t\tif err != nil {\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tdefer query.Close()\r\n\r\n\t\tcursor := sitter.NewQueryCursor()\r\n\t\tdefer cursor.Close()\r\n\r\n\t\tcursor.Exec(query, node)\r\n\r\n\t\tfor {\r\n\t\t\tmatch, ok := cursor.NextMatch()\r\n\t\t\tif !ok {\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\r\n\t\t\tfor _, capture := range match.Captures {\r\n\t\t\t\tsymbol := p.nodeToSymbol(capture.Node, content)\r\n\t\t\t\tsymbols = append(symbols, symbol)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn symbols\r\n}",
          "purpose": "",
          "range": [
            139,
            189
          ]
        },
        {
          "prototype": "func (p *TreeSitterParser) nodeToSymbol(node *sitter.Node, content []byte) models.Symbol {\r\n\tstart := node.StartPoint()\r\n\tend := node.EndPoint()\r\n\r\n\treturn models.Symbol{\r\n\t\tPrototype: string(content[node.StartByte():node.EndByte()]),\r\n\t\tPurpose:   \"\", // TODO: ä»æ³¨é‡Šæå–\r\n\t\tRange:     []int{int(start.Row) + 1, int(end.Row) + 1},\r\n\t}\r\n}",
          "purpose": "",
          "range": [
            192,
            201
          ]
        },
        {
          "prototype": "func (p *TreeSitterParser) extractFilePurpose(content []byte) string {\r\n\tlines := strings.Split(string(content), \"\\n\")\r\n\r\n\t// æŸ¥æ‰¾æ–‡ä»¶é¡¶éƒ¨çš„æ³¨é‡Š\r\n\tfor _, line := range lines[:minInt(10, len(lines))] {\r\n\t\ttrimmed := strings.TrimSpace(line)\r\n\r\n\t\t// è·³è¿‡packageå£°æ˜ç­‰\r\n\t\tif strings.HasPrefix(trimmed, \"package\") ||\r\n\t\t\tstrings.HasPrefix(trimmed, \"import\") ||\r\n\t\t\ttrimmed == \"\" {\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t\t// æŸ¥æ‰¾æ³¨é‡Š\r\n\t\tif strings.HasPrefix(trimmed, \"//\") {\r\n\t\t\tpurpose := strings.TrimSpace(strings.TrimPrefix(trimmed, \"//\"))\r\n\t\t\tif len(purpose) \u003e 10 { // è¿‡æ»¤å¤ªçŸ­çš„æ³¨é‡Š\r\n\t\t\t\treturn purpose\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// å¦‚æœé‡åˆ°ä»£ç è¡Œï¼Œåœæ­¢æŸ¥æ‰¾\r\n\t\tif !strings.HasPrefix(trimmed, \"//\") \u0026\u0026 !strings.HasPrefix(trimmed, \"#\") {\r\n\t\t\tbreak\r\n\t\t}\r\n\t}\r\n\r\n\treturn \"TODO: Describe the purpose of this file.\"\r\n}",
          "purpose": "",
          "range": [
            204,
            233
          ]
        },
        {
          "prototype": "type TreeSitterParser struct {\r\n\tlanguagesConfig models.LanguagesConfig\r\n\tparsers         map[string]*sitter.Parser\r\n}",
          "purpose": "",
          "range": [
            20,
            23
          ]
        },
        {
          "prototype": "var language *sitter.Language",
          "purpose": "",
          "range": [
            78,
            78
          ]
        },
        {
          "prototype": "var symbols []models.Symbol",
          "purpose": "",
          "range": [
            92,
            92
          ]
        },
        {
          "prototype": "var parseErr error",
          "purpose": "",
          "range": [
            93,
            93
          ]
        },
        {
          "prototype": "var symbols []models.Symbol",
          "purpose": "",
          "range": [
            140,
            140
          ]
        },
        {
          "prototype": "var language *sitter.Language",
          "purpose": "",
          "range": [
            151,
            151
          ]
        }
      ],
      "lastModified": "2025-10-07T17:10:48+08:00",
      "fileSize": 5947
    },
    "internal\\scanner\\scanner.go": {
      "purpose": "TODO: Describe the purpose of this file.",
      "symbols": [
        {
          "prototype": "func NewScanner(parser FileParser, excludePatterns []string) *Scanner {\r\n\treturn \u0026Scanner{\r\n\t\tparser:          parser,\r\n\t\texcludePatterns: excludePatterns,\r\n\t}\r\n}",
          "purpose": "",
          "range": [
            25,
            30
          ]
        },
        {
          "prototype": "func contains(slice []string, item string) bool {\r\n\tfor _, s := range slice {\r\n\t\tif s == item {\r\n\t\t\treturn true\r\n\t\t}\r\n\t}\r\n\treturn false\r\n}",
          "purpose": "",
          "range": [
            237,
            244
          ]
        },
        {
          "prototype": "func (s *Scanner) ScanProject(projectPath string) (map[string]models.FileInfo, []string, error) {\r\n\tfiles := make(map[string]models.FileInfo)\r\n\tvar techStack []string\r\n\tvar mu sync.Mutex\r\n\tvar wg sync.WaitGroup\r\n\r\n\t// ç”¨äºæ”¶é›†é”™è¯¯çš„channel\r\n\terrorChan := make(chan error, 100)\r\n\tvar scanErrors []error\r\n\r\n\t// å¯åŠ¨é”™è¯¯æ”¶é›†goroutine\r\n\tgo func() {\r\n\t\tfor err := range errorChan {\r\n\t\t\tscanErrors = append(scanErrors, err)\r\n\t\t}\r\n\t}()\r\n\r\n\t// éå†é¡¹ç›®æ–‡ä»¶\r\n\terr := filepath.Walk(projectPath, func(path string, info os.FileInfo, err error) error {\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\r\n\t\t// è·³è¿‡ç›®å½•\r\n\t\tif info.IsDir() {\r\n\t\t\t// æ£€æŸ¥æ˜¯å¦æ˜¯æ’é™¤çš„ç›®å½•\r\n\t\t\tif s.shouldExclude(path) {\r\n\t\t\t\treturn filepath.SkipDir\r\n\t\t\t}\r\n\t\t\treturn nil\r\n\t\t}\r\n\r\n\t\t// è·³è¿‡æ’é™¤çš„æ–‡ä»¶\r\n\t\tif s.shouldExclude(path) {\r\n\t\t\treturn nil\r\n\t\t}\r\n\r\n\t\t// æ£€æŸ¥æ–‡ä»¶æ‰©å±•å\r\n\t\text := filepath.Ext(path)\r\n\t\tif ext == \"\" {\r\n\t\t\treturn nil\r\n\t\t}\r\n\r\n\t\t// è·å–ç›¸å¯¹è·¯å¾„\r\n\t\trelPath, err := filepath.Rel(projectPath, path)\r\n\t\tif err != nil {\r\n\t\t\trelPath = path\r\n\t\t}\r\n\r\n\t\t// å¹¶å‘è§£ææ–‡ä»¶\r\n\t\twg.Add(1)\r\n\t\tgo func(filePath, relativePath string) {\r\n\t\t\tdefer wg.Done()\r\n\r\n\t\t\tfileInfo, err := s.parser.ParseFile(filePath)\r\n\t\t\tif err != nil {\r\n\t\t\t\terrorChan \u003c- fmt.Errorf(\"è§£ææ–‡ä»¶ %s å¤±è´¥: %w\", relativePath, err)\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\r\n\t\t\t// å®‰å…¨åœ°æ›´æ–°ç»“æœ\r\n\t\t\tmu.Lock()\r\n\t\t\tfiles[relativePath] = *fileInfo\r\n\r\n\t\t\t// æ”¶é›†æŠ€æœ¯æ ˆä¿¡æ¯\r\n\t\t\tlang := s.getLanguageFromExtension(ext)\r\n\t\t\tif lang != \"\" \u0026\u0026 !contains(techStack, lang) {\r\n\t\t\t\ttechStack = append(techStack, lang)\r\n\t\t\t}\r\n\t\t\tmu.Unlock()\r\n\t\t}(path, relPath)\r\n\r\n\t\treturn nil\r\n\t})\r\n\r\n\t// ç­‰å¾…æ‰€æœ‰goroutineå®Œæˆ\r\n\twg.Wait()\r\n\tclose(errorChan)\r\n\r\n\tif err != nil {\r\n\t\treturn nil, nil, fmt.Errorf(\"æ‰«æé¡¹ç›®å¤±è´¥: %w\", err)\r\n\t}\r\n\r\n\t// å¦‚æœæœ‰æ‰«æé”™è¯¯ï¼Œè®°å½•ä½†ä¸ä¸­æ–­\r\n\tif len(scanErrors) \u003e 0 {\r\n\t\tfmt.Printf(\"è­¦å‘Š: æ‰«æè¿‡ç¨‹ä¸­é‡åˆ° %d ä¸ªé”™è¯¯:\\n\", len(scanErrors))\r\n\t\tfor i, err := range scanErrors {\r\n\t\t\tif i \u003c 5 { // åªæ˜¾ç¤ºå‰5ä¸ªé”™è¯¯\r\n\t\t\t\tfmt.Printf(\"  - %v\\n\", err)\r\n\t\t\t}\r\n\t\t}\r\n\t\tif len(scanErrors) \u003e 5 {\r\n\t\t\tfmt.Printf(\"  ... è¿˜æœ‰ %d ä¸ªé”™è¯¯\\n\", len(scanErrors)-5)\r\n\t\t}\r\n\t}\r\n\r\n\treturn files, techStack, nil\r\n}",
          "purpose": "",
          "range": [
            33,
            130
          ]
        },
        {
          "prototype": "func (s *Scanner) shouldExclude(path string) bool {\r\n\t// é»˜è®¤æ’é™¤æ¨¡å¼\r\n\tdefaultExcludes := []string{\r\n\t\t\".git\",\r\n\t\t\".svn\",\r\n\t\t\".hg\",\r\n\t\t\"node_modules\",\r\n\t\t\"vendor\",\r\n\t\t\".idea\",\r\n\t\t\".vscode\",\r\n\t\t\"__pycache__\",\r\n\t\t\".DS_Store\",\r\n\t\t\"*.tmp\",\r\n\t\t\"*.log\",\r\n\t}\r\n\r\n\t// åˆå¹¶ç”¨æˆ·æŒ‡å®šçš„æ’é™¤æ¨¡å¼\r\n\tallExcludes := append(defaultExcludes, s.excludePatterns...)\r\n\r\n\tfor _, pattern := range allExcludes {\r\n\t\t// ç®€å•çš„æ¨¡å¼åŒ¹é…\r\n\t\tif strings.Contains(path, pattern) {\r\n\t\t\treturn true\r\n\t\t}\r\n\r\n\t\t// é€šé…ç¬¦åŒ¹é…\r\n\t\tif matched, _ := filepath.Match(pattern, filepath.Base(path)); matched {\r\n\t\t\treturn true\r\n\t\t}\r\n\t}\r\n\r\n\treturn false\r\n}",
          "purpose": "",
          "range": [
            133,
            165
          ]
        },
        {
          "prototype": "func (s *Scanner) getLanguageFromExtension(ext string) string {\r\n\tlanguageMap := map[string]string{\r\n\t\t\".go\":         \"Go\",\r\n\t\t\".js\":         \"JavaScript\",\r\n\t\t\".jsx\":        \"JavaScript\",\r\n\t\t\".ts\":         \"TypeScript\",\r\n\t\t\".tsx\":        \"TypeScript\",\r\n\t\t\".py\":         \"Python\",\r\n\t\t\".java\":       \"Java\",\r\n\t\t\".c\":          \"C\",\r\n\t\t\".cpp\":        \"C++\",\r\n\t\t\".cc\":         \"C++\",\r\n\t\t\".cxx\":        \"C++\",\r\n\t\t\".h\":          \"C/C++\",\r\n\t\t\".hpp\":        \"C++\",\r\n\t\t\".cs\":         \"C#\",\r\n\t\t\".php\":        \"PHP\",\r\n\t\t\".rb\":         \"Ruby\",\r\n\t\t\".rs\":         \"Rust\",\r\n\t\t\".swift\":      \"Swift\",\r\n\t\t\".kt\":         \"Kotlin\",\r\n\t\t\".scala\":      \"Scala\",\r\n\t\t\".clj\":        \"Clojure\",\r\n\t\t\".hs\":         \"Haskell\",\r\n\t\t\".ml\":         \"OCaml\",\r\n\t\t\".fs\":         \"F#\",\r\n\t\t\".lua\":        \"Lua\",\r\n\t\t\".r\":          \"R\",\r\n\t\t\".m\":          \"Objective-C\",\r\n\t\t\".mm\":         \"Objective-C++\",\r\n\t\t\".dart\":       \"Dart\",\r\n\t\t\".elm\":        \"Elm\",\r\n\t\t\".ex\":         \"Elixir\",\r\n\t\t\".exs\":        \"Elixir\",\r\n\t\t\".erl\":        \"Erlang\",\r\n\t\t\".hrl\":        \"Erlang\",\r\n\t\t\".sql\":        \"SQL\",\r\n\t\t\".sh\":         \"Shell\",\r\n\t\t\".bash\":       \"Bash\",\r\n\t\t\".zsh\":        \"Zsh\",\r\n\t\t\".fish\":       \"Fish\",\r\n\t\t\".ps1\":        \"PowerShell\",\r\n\t\t\".html\":       \"HTML\",\r\n\t\t\".css\":        \"CSS\",\r\n\t\t\".scss\":       \"SCSS\",\r\n\t\t\".sass\":       \"Sass\",\r\n\t\t\".less\":       \"Less\",\r\n\t\t\".xml\":        \"XML\",\r\n\t\t\".json\":       \"JSON\",\r\n\t\t\".yaml\":       \"YAML\",\r\n\t\t\".yml\":        \"YAML\",\r\n\t\t\".toml\":       \"TOML\",\r\n\t\t\".ini\":        \"INI\",\r\n\t\t\".cfg\":        \"Config\",\r\n\t\t\".conf\":       \"Config\",\r\n\t\t\".md\":         \"Markdown\",\r\n\t\t\".tex\":        \"LaTeX\",\r\n\t\t\".dockerfile\": \"Docker\",\r\n\t\t\".Dockerfile\": \"Docker\",\r\n\t}\r\n\r\n\tif lang, exists := languageMap[ext]; exists {\r\n\t\treturn lang\r\n\t}\r\n\r\n\treturn \"\"\r\n}",
          "purpose": "",
          "range": [
            168,
            234
          ]
        },
        {
          "prototype": "type FileParser interface {\r\n\tParseFile(filePath string) (*models.FileInfo, error)\r\n}",
          "purpose": "",
          "range": [
            14,
            16
          ]
        },
        {
          "prototype": "type Scanner struct {\r\n\tparser          FileParser\r\n\texcludePatterns []string\r\n}",
          "purpose": "",
          "range": [
            19,
            22
          ]
        },
        {
          "prototype": "var techStack []string",
          "purpose": "",
          "range": [
            35,
            35
          ]
        },
        {
          "prototype": "var mu sync.Mutex",
          "purpose": "",
          "range": [
            36,
            36
          ]
        },
        {
          "prototype": "var wg sync.WaitGroup",
          "purpose": "",
          "range": [
            37,
            37
          ]
        },
        {
          "prototype": "var scanErrors []error",
          "purpose": "",
          "range": [
            41,
            41
          ]
        }
      ],
      "lastModified": "2025-10-07T16:36:19+08:00",
      "fileSize": 5541
    },
    "internal\\scanner\\scanner_test.go": {
      "purpose": "TODO: Describe the purpose of this file.",
      "symbols": [
        {
          "prototype": "func TestNewScanner(t *testing.T) {\r\n\tparser := \u0026mockParser{}\r\n\texcludePatterns := []string{\"test\", \"temp\"}\r\n\r\n\tscanner := NewScanner(parser, excludePatterns)\r\n\tassert.NotNil(t, scanner)\r\n\tassert.Equal(t, parser, scanner.parser)\r\n\tassert.Equal(t, excludePatterns, scanner.excludePatterns)\r\n}",
          "purpose": "",
          "range": [
            32,
            40
          ]
        },
        {
          "prototype": "func TestScanProject(t *testing.T) {\r\n\t// åˆ›å»ºä¸´æ—¶æµ‹è¯•ç›®å½•\r\n\ttmpDir := t.TempDir()\r\n\r\n\t// åˆ›å»ºæµ‹è¯•æ–‡ä»¶\r\n\tcreateTestFile(t, tmpDir, \"main.go\", goTestCode)\r\n\tcreateTestFile(t, tmpDir, \"helper.js\", jsTestCode)\r\n\tcreateTestFile(t, tmpDir, \"README.md\", \"# Test\")\r\n\r\n\t// åˆ›å»ºå­ç›®å½•\r\n\tsubDir := filepath.Join(tmpDir, \"subdir\")\r\n\tos.MkdirAll(subDir, 0755)\r\n\tcreateTestFile(t, subDir, \"utils.go\", goTestCode)\r\n\r\n\t// åˆ›å»ºè§£æå™¨\r\n\tparser := \u0026mockParser{}\r\n\tscanner := NewScanner(parser, nil)\r\n\r\n\t// æ‰«æé¡¹ç›®\r\n\tfiles, techStack, err := scanner.ScanProject(tmpDir)\r\n\r\n\trequire.NoError(t, err)\r\n\tassert.NotNil(t, files)\r\n\tassert.NotNil(t, techStack)\r\n\r\n\t// éªŒè¯ç»“æœ\r\n\tassert.GreaterOrEqual(t, len(files), 2) // è‡³å°‘åŒ…å« .go å’Œ .js æ–‡ä»¶\r\n\tassert.Contains(t, techStack, \"Go\")\r\n\tassert.Contains(t, techStack, \"JavaScript\")\r\n}",
          "purpose": "",
          "range": [
            42,
            71
          ]
        },
        {
          "prototype": "func TestScanProjectWithExcludePatterns(t *testing.T) {\r\n\t// åˆ›å»ºä¸´æ—¶æµ‹è¯•ç›®å½•\r\n\ttmpDir := t.TempDir()\r\n\r\n\t// åˆ›å»ºæµ‹è¯•æ–‡ä»¶\r\n\tcreateTestFile(t, tmpDir, \"main.go\", goTestCode)\r\n\tcreateTestFile(t, tmpDir, \"test.go\", goTestCode)\r\n\tcreateTestFile(t, tmpDir, \"temp.js\", jsTestCode)\r\n\r\n\t// åˆ›å»ºè§£æå™¨ï¼Œæ’é™¤åŒ…å« \"test\" å’Œ \"temp\" çš„æ–‡ä»¶\r\n\tparser := \u0026mockParser{}\r\n\texcludePatterns := []string{\"test\", \"temp\"}\r\n\tscanner := NewScanner(parser, excludePatterns)\r\n\r\n\t// æ‰«æé¡¹ç›®\r\n\tfiles, _, err := scanner.ScanProject(tmpDir)\r\n\r\n\trequire.NoError(t, err)\r\n\tassert.NotNil(t, files)\r\n\r\n\t// éªŒè¯æ’é™¤çš„æ–‡ä»¶ä¸åœ¨ç»“æœä¸­\r\n\tfor filePath := range files {\r\n\t\tassert.NotContains(t, filePath, \"test\")\r\n\t\tassert.NotContains(t, filePath, \"temp\")\r\n\t}\r\n}",
          "purpose": "",
          "range": [
            73,
            98
          ]
        },
        {
          "prototype": "func TestShouldExclude(t *testing.T) {\r\n\tscanner := \u0026Scanner{}\r\n\r\n\t// æµ‹è¯•é»˜è®¤æ’é™¤æ¨¡å¼\r\n\ttestCases := []struct {\r\n\t\tpath     string\r\n\t\texpected bool\r\n\t}{\r\n\t\t{\".git/config\", true},\r\n\t\t{\"node_modules/package\", true},\r\n\t\t{\"vendor/dependency\", true},\r\n\t\t{\"main.go\", false},\r\n\t\t{\"src/main.go\", false},\r\n\t\t{\".DS_Store\", true},\r\n\t\t{\"temp.log\", true},\r\n\t}\r\n\r\n\tfor _, tc := range testCases {\r\n\t\tt.Run(tc.path, func(t *testing.T) {\r\n\t\t\tresult := scanner.shouldExclude(tc.path)\r\n\t\t\tassert.Equal(t, tc.expected, result)\r\n\t\t})\r\n\t}\r\n}",
          "purpose": "",
          "range": [
            100,
            123
          ]
        },
        {
          "prototype": "func TestShouldExcludeWithCustomPatterns(t *testing.T) {\r\n\texcludePatterns := []string{\"test\", \"temp\"}\r\n\tscanner := NewScanner(\u0026mockParser{}, excludePatterns)\r\n\r\n\ttestCases := []struct {\r\n\t\tpath     string\r\n\t\texpected bool\r\n\t}{\r\n\t\t{\"test.go\", true},\r\n\t\t{\"temp.js\", true},\r\n\t\t{\"main.go\", false},\r\n\t\t{\"src/main.go\", false},\r\n\t\t{\"latest.go\", true}, // åŒ…å« \"test\"\r\n\t}\r\n\r\n\tfor _, tc := range testCases {\r\n\t\tt.Run(tc.path, func(t *testing.T) {\r\n\t\t\tresult := scanner.shouldExclude(tc.path)\r\n\t\t\tassert.Equal(t, tc.expected, result)\r\n\t\t})\r\n\t}\r\n}",
          "purpose": "",
          "range": [
            125,
            146
          ]
        },
        {
          "prototype": "func TestGetLanguageFromExtension(t *testing.T) {\r\n\tscanner := \u0026Scanner{}\r\n\r\n\ttestCases := []struct {\r\n\t\text      string\r\n\t\texpected string\r\n\t}{\r\n\t\t{\".go\", \"Go\"},\r\n\t\t{\".js\", \"JavaScript\"},\r\n\t\t{\".jsx\", \"JavaScript\"},\r\n\t\t{\".ts\", \"TypeScript\"},\r\n\t\t{\".py\", \"Python\"},\r\n\t\t{\".java\", \"Java\"},\r\n\t\t{\".cs\", \"C#\"},\r\n\t\t{\".rs\", \"Rust\"},\r\n\t\t{\".cpp\", \"C++\"},\r\n\t\t{\".c\", \"C\"},\r\n\t\t{\".txt\", \"\"},\r\n\t\t{\"\", \"\"},\r\n\t}\r\n\r\n\tfor _, tc := range testCases {\r\n\t\tt.Run(tc.ext, func(t *testing.T) {\r\n\t\t\tresult := scanner.getLanguageFromExtension(tc.ext)\r\n\t\t\tassert.Equal(t, tc.expected, result)\r\n\t\t})\r\n\t}\r\n}",
          "purpose": "",
          "range": [
            148,
            175
          ]
        },
        {
          "prototype": "func TestContains(t *testing.T) {\r\n\ttestCases := []struct {\r\n\t\tslice    []string\r\n\t\titem     string\r\n\t\texpected bool\r\n\t}{\r\n\t\t{[]string{\"go\", \"js\", \"py\"}, \"go\", true},\r\n\t\t{[]string{\"go\", \"js\", \"py\"}, \"js\", true},\r\n\t\t{[]string{\"go\", \"js\", \"py\"}, \"java\", false},\r\n\t\t{[]string{}, \"go\", false},\r\n\t\t{nil, \"go\", false},\r\n\t}\r\n\r\n\tfor _, tc := range testCases {\r\n\t\tt.Run(tc.item, func(t *testing.T) {\r\n\t\t\tresult := contains(tc.slice, tc.item)\r\n\t\t\tassert.Equal(t, tc.expected, result)\r\n\t\t})\r\n\t}\r\n}",
          "purpose": "",
          "range": [
            177,
            196
          ]
        },
        {
          "prototype": "func TestScanProjectEmptyDirectory(t *testing.T) {\r\n\t// åˆ›å»ºç©ºç›®å½•\r\n\ttmpDir := t.TempDir()\r\n\r\n\tparser := \u0026mockParser{}\r\n\tscanner := NewScanner(parser, nil)\r\n\r\n\tfiles, techStack, err := scanner.ScanProject(tmpDir)\r\n\r\n\trequire.NoError(t, err)\r\n\tassert.Empty(t, files)\r\n\tassert.Empty(t, techStack)\r\n}",
          "purpose": "",
          "range": [
            198,
            210
          ]
        },
        {
          "prototype": "func TestScanProjectWithErrors(t *testing.T) {\r\n\t// åˆ›å»ºä¸´æ—¶æµ‹è¯•ç›®å½•\r\n\ttmpDir := t.TempDir()\r\n\r\n\t// åˆ›å»ºæµ‹è¯•æ–‡ä»¶\r\n\tcreateTestFile(t, tmpDir, \"main.go\", goTestCode)\r\n\r\n\t// åˆ›å»ºä¼šå¤±è´¥çš„è§£æå™¨\r\n\tfailingParser := \u0026failingParser{}\r\n\tscanner := NewScanner(failingParser, nil)\r\n\r\n\t// æ‰«æé¡¹ç›®ï¼ˆåº”è¯¥å¤„ç†é”™è¯¯ä½†ä¸ä¸­æ–­ï¼‰\r\n\tfiles, techStack, err := scanner.ScanProject(tmpDir)\r\n\r\n\t// åº”è¯¥æˆåŠŸï¼Œä½†æ–‡ä»¶å¯èƒ½ä¸ºç©º\r\n\trequire.NoError(t, err)\r\n\r\n\t// æ£€æŸ¥è¿”å›å€¼ï¼ˆå…è®¸ä¸º nil æˆ–ç©ºï¼‰\r\n\t_ = files\r\n\t_ = techStack\r\n}",
          "purpose": "",
          "range": [
            212,
            232
          ]
        },
        {
          "prototype": "func createTestFile(t *testing.T, dir, name, content string) {\r\n\tpath := filepath.Join(dir, name)\r\n\terr := os.WriteFile(path, []byte(content), 0644)\r\n\trequire.NoError(t, err)\r\n}",
          "purpose": "",
          "range": [
            236,
            240
          ]
        },
        {
          "prototype": "func (m *mockParser) ParseFile(filePath string) (*models.FileInfo, error) {\r\n\t// æ¨¡æ‹Ÿè§£æç»“æœ\r\n\treturn \u0026models.FileInfo{\r\n\t\tPurpose: \"Mock file\",\r\n\t\tSymbols: []models.Symbol{\r\n\t\t\t{\r\n\t\t\t\tPrototype: \"func mock()\",\r\n\t\t\t\tPurpose:   \"Mock function\",\r\n\t\t\t\tRange:     []int{1, 1},\r\n\t\t\t},\r\n\t\t},\r\n\t\tLastModified: \"2025-10-07T00:00:00Z\",\r\n\t\tFileSize:     100,\r\n\t}, nil\r\n}",
          "purpose": "",
          "range": [
            16,
            30
          ]
        },
        {
          "prototype": "func (f *failingParser) ParseFile(filePath string) (*models.FileInfo, error) {\r\n\treturn nil, assert.AnError\r\n}",
          "purpose": "",
          "range": [
            245,
            247
          ]
        },
        {
          "prototype": "type mockParser struct{}",
          "purpose": "",
          "range": [
            14,
            14
          ]
        },
        {
          "prototype": "type failingParser struct{}",
          "purpose": "",
          "range": [
            243,
            243
          ]
        },
        {
          "prototype": "const goTestCode = `package main\r\n\r\nfunc main() {\r\n    println(\"test\")\r\n}\r\n`",
          "purpose": "",
          "range": [
            249,
            254
          ]
        },
        {
          "prototype": "const jsTestCode = `function test() {\r\n    console.log(\"test\");\r\n}\r\n`",
          "purpose": "",
          "range": [
            256,
            259
          ]
        }
      ],
      "lastModified": "2025-10-07T16:36:19+08:00",
      "fileSize": 6120
    },
    "internal\\updater\\incremental.go": {
      "purpose": "TODO: Describe the purpose of this file.",
      "symbols": [
        {
          "prototype": "func NewIncrementalUpdater(p scanner.FileParser) *IncrementalUpdater {\n\treturn \u0026IncrementalUpdater{\n\t\tparser: p,\n\t}\n}",
          "purpose": "",
          "range": [
            21,
            25
          ]
        },
        {
          "prototype": "func (u *IncrementalUpdater) UpdateProject(contextPath, projectPath string, excludePatterns []string) (*models.ProjectContext, []FileChange, error) {\n\t// 1. åŠ è½½ç°æœ‰çš„é¡¹ç›®ä¸Šä¸‹æ–‡\n\texistingContext, err := u.loadExistingContext(contextPath)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"åŠ è½½ç°æœ‰ä¸Šä¸‹æ–‡å¤±è´¥: %w\", err)\n\t}\n\n\t// 2. æ‰«æé¡¹ç›®æ–‡ä»¶ï¼Œæ£€æµ‹å˜æ›´\n\tchanges, err := u.detectFileChanges(existingContext, projectPath, excludePatterns)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"æ£€æµ‹æ–‡ä»¶å˜æ›´å¤±è´¥: %w\", err)\n\t}\n\n\t// 3. å¦‚æœæ²¡æœ‰å˜æ›´ï¼Œç›´æ¥è¿”å›\n\tif len(changes) == 0 {\n\t\tfmt.Println(\"âœ… æ²¡æœ‰æ£€æµ‹åˆ°æ–‡ä»¶å˜æ›´\")\n\t\treturn existingContext, changes, nil\n\t}\n\n\t// 4. åº”ç”¨å˜æ›´\n\tupdatedContext, err := u.applyChanges(existingContext, changes)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"åº”ç”¨å˜æ›´å¤±è´¥: %w\", err)\n\t}\n\n\t// 5. æ›´æ–°æ—¶é—´æˆ³\n\tupdatedContext.LastUpdated = time.Now()\n\n\treturn updatedContext, changes, nil\n}",
          "purpose": "",
          "range": [
            45,
            74
          ]
        },
        {
          "prototype": "func (u *IncrementalUpdater) loadExistingContext(contextPath string) (*models.ProjectContext, error) {\n\tif _, err := os.Stat(contextPath); os.IsNotExist(err) {\n\t\treturn nil, fmt.Errorf(\"ä¸Šä¸‹æ–‡æ–‡ä»¶ä¸å­˜åœ¨: %s\", contextPath)\n\t}\n\n\tdata, err := os.ReadFile(contextPath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"è¯»å–ä¸Šä¸‹æ–‡æ–‡ä»¶å¤±è´¥: %w\", err)\n\t}\n\n\tvar context models.ProjectContext\n\tif err := json.Unmarshal(data, \u0026context); err != nil {\n\t\treturn nil, fmt.Errorf(\"è§£æä¸Šä¸‹æ–‡æ–‡ä»¶å¤±è´¥: %w\", err)\n\t}\n\n\treturn \u0026context, nil\n}",
          "purpose": "",
          "range": [
            77,
            93
          ]
        },
        {
          "prototype": "func (u *IncrementalUpdater) detectFileChanges(context *models.ProjectContext, projectPath string, excludePatterns []string) ([]FileChange, error) {\n\tvar changes []FileChange\n\tcurrentFiles := make(map[string]bool)\n\n\t// éå†é¡¹ç›®æ–‡ä»¶\n\terr := filepath.Walk(projectPath, func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// è·³è¿‡ç›®å½•\n\t\tif info.IsDir() {\n\t\t\treturn nil\n\t\t}\n\n\t\t// æ£€æŸ¥æ˜¯å¦åº”è¯¥æ’é™¤\n\t\tif u.shouldExclude(path, excludePatterns) {\n\t\t\treturn nil\n\t\t}\n\n\t\t// æ£€æŸ¥æ˜¯å¦ä¸ºæ”¯æŒçš„æ–‡ä»¶ç±»å‹\n\t\text := filepath.Ext(path)\n\t\tif !u.isSupportedFile(ext) {\n\t\t\treturn nil\n\t\t}\n\n\t\t// è½¬æ¢ä¸ºç›¸å¯¹è·¯å¾„\n\t\trelPath, err := filepath.Rel(projectPath, path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trelPath = filepath.ToSlash(relPath) // ç»Ÿä¸€ä½¿ç”¨æ–œæ \n\n\t\tcurrentFiles[relPath] = true\n\n\t\t// æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨äºä¸Šä¸‹æ–‡ä¸­\n\t\texistingFile, exists := context.Files[relPath]\n\t\tif !exists {\n\t\t\t// æ–°æ–‡ä»¶\n\t\t\tnewInfo, err := u.parser.ParseFile(path)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tchanges = append(changes, FileChange{\n\t\t\t\tPath:       relPath,\n\t\t\t\tChangeType: FileAdded,\n\t\t\t\tNewInfo:    newInfo,\n\t\t\t})\n\t\t} else {\n\t\t\t// æ£€æŸ¥æ–‡ä»¶æ˜¯å¦è¢«ä¿®æ”¹\n\t\t\tif u.isFileModified(path, \u0026existingFile) {\n\t\t\t\tnewInfo, err := u.parser.ParseFile(path)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tchanges = append(changes, FileChange{\n\t\t\t\t\tPath:       relPath,\n\t\t\t\t\tChangeType: FileModified,\n\t\t\t\t\tOldInfo:    \u0026existingFile,\n\t\t\t\t\tNewInfo:    newInfo,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t})\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// æ£€æŸ¥å·²åˆ é™¤çš„æ–‡ä»¶\n\tfor filePath := range context.Files {\n\t\tif !currentFiles[filePath] {\n\t\t\texistingFile := context.Files[filePath]\n\t\t\tchanges = append(changes, FileChange{\n\t\t\t\tPath:       filePath,\n\t\t\t\tChangeType: FileDeleted,\n\t\t\t\tOldInfo:    \u0026existingFile,\n\t\t\t})\n\t\t}\n\t}\n\n\treturn changes, nil\n}",
          "purpose": "",
          "range": [
            96,
            180
          ]
        },
        {
          "prototype": "func (u *IncrementalUpdater) isFileModified(filePath string, existingInfo *models.FileInfo) bool {\n\tfileInfo, err := os.Stat(filePath)\n\tif err != nil {\n\t\treturn true // å¦‚æœæ— æ³•è·å–æ–‡ä»¶ä¿¡æ¯ï¼Œå‡è®¾å·²ä¿®æ”¹\n\t}\n\n\t// æ¯”è¾ƒä¿®æ”¹æ—¶é—´å’Œæ–‡ä»¶å¤§å°\n\tcurrentModTime := fileInfo.ModTime().Format(time.RFC3339)\n\tcurrentSize := fileInfo.Size()\n\n\treturn currentModTime != existingInfo.LastModified || currentSize != existingInfo.FileSize\n}",
          "purpose": "",
          "range": [
            183,
            194
          ]
        },
        {
          "prototype": "func (u *IncrementalUpdater) applyChanges(context *models.ProjectContext, changes []FileChange) (*models.ProjectContext, error) {\n\t// åˆ›å»ºä¸Šä¸‹æ–‡å‰¯æœ¬\n\tupdatedContext := *context\n\tupdatedFiles := make(map[string]models.FileInfo)\n\n\t// å¤åˆ¶ç°æœ‰æ–‡ä»¶\n\tfor path, info := range context.Files {\n\t\tupdatedFiles[path] = info\n\t}\n\n\t// åº”ç”¨å˜æ›´\n\tfor _, change := range changes {\n\t\tswitch change.ChangeType {\n\t\tcase FileAdded:\n\t\t\tupdatedFiles[change.Path] = *change.NewInfo\n\t\t\tfmt.Printf(\"â• æ·»åŠ æ–‡ä»¶: %s\\n\", change.Path)\n\t\tcase FileModified:\n\t\t\tupdatedFiles[change.Path] = *change.NewInfo\n\t\t\tfmt.Printf(\"âœï¸  ä¿®æ”¹æ–‡ä»¶: %s\\n\", change.Path)\n\t\tcase FileDeleted:\n\t\t\tdelete(updatedFiles, change.Path)\n\t\t\tfmt.Printf(\"ğŸ—‘ï¸  åˆ é™¤æ–‡ä»¶: %s\\n\", change.Path)\n\t\t}\n\t}\n\n\tupdatedContext.Files = updatedFiles\n\n\t// é‡æ–°ç”Ÿæˆæ¨¡å—æ‘˜è¦\n\tupdatedContext.Architecture.ModuleSummary = u.generateModuleSummary(updatedFiles)\n\n\treturn \u0026updatedContext, nil\n}",
          "purpose": "",
          "range": [
            197,
            228
          ]
        },
        {
          "prototype": "func (u *IncrementalUpdater) generateModuleSummary(files map[string]models.FileInfo) map[string]string {\n\tmoduleSummary := make(map[string]string)\n\tmoduleFiles := make(map[string][]string)\n\n\t// æŒ‰æ¨¡å—åˆ†ç»„æ–‡ä»¶\n\tfor filePath := range files {\n\t\tdir := filepath.Dir(filePath)\n\t\tif dir == \".\" {\n\t\t\tdir = \"root\"\n\t\t}\n\t\tmoduleFiles[dir] = append(moduleFiles[dir], filepath.Base(filePath))\n\t}\n\n\t// ç”Ÿæˆæ‘˜è¦\n\tfor module, fileList := range moduleFiles {\n\t\tif len(fileList) == 1 {\n\t\t\tmoduleSummary[module] = fmt.Sprintf(\"åŒ…å« 1 ä¸ªæ–‡ä»¶: %s\", fileList[0])\n\t\t} else {\n\t\t\tmoduleSummary[module] = fmt.Sprintf(\"åŒ…å« %d ä¸ªæ–‡ä»¶: %s\", len(fileList), strings.Join(fileList, \", \"))\n\t\t}\n\t}\n\n\treturn moduleSummary\n}",
          "purpose": "",
          "range": [
            231,
            254
          ]
        },
        {
          "prototype": "func (u *IncrementalUpdater) shouldExclude(path string, excludePatterns []string) bool {\n\tpath = filepath.ToSlash(path)\n\tfor _, pattern := range excludePatterns {\n\t\tif matched, _ := filepath.Match(pattern, path); matched {\n\t\t\treturn true\n\t\t}\n\t\tif strings.Contains(path, pattern) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}",
          "purpose": "",
          "range": [
            257,
            268
          ]
        },
        {
          "prototype": "func (u *IncrementalUpdater) isSupportedFile(ext string) bool {\n\tsupportedExts := []string{\".go\", \".js\", \".jsx\", \".ts\", \".tsx\", \".py\", \".java\", \".cs\", \".rs\", \".cpp\", \".c\", \".h\"}\n\tfor _, supportedExt := range supportedExts {\n\t\tif ext == supportedExt {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}",
          "purpose": "",
          "range": [
            271,
            279
          ]
        },
        {
          "prototype": "type IncrementalUpdater struct {\n\tparser scanner.FileParser\n}",
          "purpose": "",
          "range": [
            16,
            18
          ]
        },
        {
          "prototype": "type FileChangeType int",
          "purpose": "",
          "range": [
            28,
            28
          ]
        },
        {
          "prototype": "type FileChange struct {\n\tPath       string\n\tChangeType FileChangeType\n\tOldInfo    *models.FileInfo\n\tNewInfo    *models.FileInfo\n}",
          "purpose": "",
          "range": [
            37,
            42
          ]
        },
        {
          "prototype": "const (\n\tFileAdded FileChangeType = iota\n\tFileModified\n\tFileDeleted\n)",
          "purpose": "",
          "range": [
            30,
            34
          ]
        },
        {
          "prototype": "var context models.ProjectContext",
          "purpose": "",
          "range": [
            87,
            87
          ]
        },
        {
          "prototype": "var changes []FileChange",
          "purpose": "",
          "range": [
            97,
            97
          ]
        }
      ],
      "lastModified": "2025-10-07T16:36:19+08:00",
      "fileSize": 7294
    }
  }
}